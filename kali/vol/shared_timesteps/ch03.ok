= Verification

== Yoshida

*Bob*: We can now put our distance measurement tool to good use, by
testing whether our shared time step integrator really does the right
thing.
We'll do a test run with the constant time step code first,
and then compare the results with that from the shared time step
code.

*Alice*: Let's take a fancy integrator.  How about Yoshida's sixth order
scheme?

*Bob*: As you wish.  And while we're at it, let's check whether the scheme
is still sixth order, in constant as well as shared time step form.  First
I'll prepare initial conditions with the particles all properly numbered:

 : command: rm -f test.in
 :commandoutput: mkplummer.rb -n 5 -s 1 | acsnumber.rb > test.in

Starting with the constant time step version, let's choose the
<tt>yo6</tt> integrator, but what options did we use for algorithm
choice?  I always forget what names we gave our options.  Let's ask
our clop function to provide them:

 :commandoutput: nbody_cst1.rb -h

== Energy Scaling

Aha, now I remember.  Okay, how about this?

 :commandoutput: nbody_cst1.rb -m yo6 -t 1 < test.in > yo6cst.out

Now let's make the time step twice as small:

 :commandoutput: nbody_cst1.rb -m yo6 -t 1 -d 0.005 < test.in > yo6cst_half.out

== Phase Space Distance Scaling

*Alice*: Indeed, sixth order!  Very close to a factor <tex>$2^6=64$</tex>
difference.  But before we go further, and use our shared time step
integrator, let's first see whether in this case the distance
in phase space also scales like the sixth power in the time step.

*Bob*: Ah, yes, good idea.  But in order to do so, we have to know what the
`true' solution is.  When we check energy conservation, we know that a
truly accurate integration would give us an energy error of zero, but when
we compare the two outputs we just got, we need to compare them to an even
more accurate soluation.  Well, we can run our code with a much smaller
time step, and declare that the result should be close to `true':

 :commandoutput: nbody_cst1.rb -m yo6 -t 1 -d 0.001 < test.in > yo6cst_tenth.out

First we'll compare the first run with the `true' run:

 :commandoutput: cat yo6cst.out yo6cst_tenth.out | acsdiff.rb

And second we'll take the second run, to compare it with the `true' one:

 :commandoutput: cat yo6cst_half.out yo6cst_tenth.out | acsdiff.rb

*Alice*: Wow, very nice indeed!  Almost exactly a factor 64 smaller.

== The Shared Time Step Code

*Bob*: After all these preliminaries, we can finally test our shared time
step code:

 :commandoutput: nbody_sh1.rb -m yo6 -t 1 < test.in > yo6sh.out

That's quite accurate!  This means that, if all is well, the distance between
this output and that of the previous `true' output should be a lot smaller
than the distance between the more accurate run with constant time
steps and the `true' output.  Let's check:

 :commandoutput: cat yo6sh.out yo6cst_tenth.out | acsdiff.rb

*Alice*: What is that?!?

*Bob*: That sure doesn't look good.  How can the distance be so large?






xxxx

xxxx

xxxx

why not more accurate for variable time step?
		    write nbodydiff

discuss how to extend it to variable time steps, then implement:
nbody_cst1.rb

nbody_sh1.rb

nbody_ind1.rb

nbody_ind2.rb

nbody_ind3.rb

world1.rb

world2.rb

world3.rb
