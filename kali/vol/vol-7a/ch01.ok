= Shared Time Steps

== Picking up the Pieces

*Alice*: We have been quite busy with our project to lay the foundations
for a N-body simulation environment.

*Bob*: I'd say!  It seems like ages since we did some actual N-body
calculations.  We started with the two-body problem . . .

*Alice*: . . . and then you got carried away, adding one integrator after
another, before we finally moved on to the general N-body problem . . .

*Bob*: . . . at which point you told us to stop moving, and to lay
foundations instead!  I feel like we turned into computer scientists
instead of astrophysicists.

*Alice*: I'm afraid we had no choice.  The alternative would have been
to come up with stopgap solutions at every turn in the road.  Now at least
we have a reliable and flexible data format and corresponding I/O routines,
and we have an extendable command line options argument which makes our codes
self-describing through a detailed help facility, and so on.

*Bob*: I must admit, all those features do make life easier.  I remember
getting rather tired, editing a file each time I wanted to perform a different
run.  Okay, where were we?

*Alice*: In volume ???acsio??? we had collected the various integrators in a
single file <tt>nbody_cst1.rb</tt>, while we were getting the ACS data format
straightened out.  Let us start from the same file, in the new directory,
corresponding to this volume ???world1???.

*Bob*: Do you remember how to run it?

*Alice*: Don't have to!  Remember, we had a <tt>---help</tt> option, which
should give not only a detailed description of what the codes does, but in
addition it should give a simple example invocation.

*Bob*: Ah, yes, that's one of the nifty features we added.  We've sure done
a lot!  Let's try:

 :commandoutput: ruby nbody_cst1.rb ---help

Well, let's follow the advice:

 :commandoutput: ruby mkplummer.rb -n 5 -s 1 | ruby nbody_cst1.rb -d 0.001 -t 1 > /dev/null

== Brevity

*Alice*: That all seems quite reasonable.

*Bob*: Before we continue, let's make life a little easier still.  I've been
getting tired of typing +ruby+ every single time we are running a script.
In one of the Ruby books I looked it, I came across the suggestion to put
the following line at the top of a ruby file:

  #!/usr/local/bin/ruby -w

If we add this to <tt>nbody_cst1.rb</tt> and then make the file executable,
by typing

  chmod +x nbody_cst1.rb

we can just type the file name, leaving out the +ruby+ command.

*Alice*: I see: the file itself has become executable, and the shell in which
we are executing the file is being told what to run, namely to run
+ruby+, which is stored in <tt>/usr/local/bin/</tt>.  But what does the
<tt>-w</tt> mean?

*Bob*: It generates warnings.  It is equivalent to running a code with
the command <tt>ruby -w</tt>.

*Alice*: That doesn't sound like your cup of tea, to get extra warning
messages.

*Bob*: Indeed, I don't like getting too many warning messages, but in the
case of running Ruby I've found it quite useful.  Unlike some programs
I know, the Ruby interpreter doesn't overdo its warning job.

*Alice*: Let's add your lines to the various ruby codes we have lying around
here, and check whether it works.  And we may as well make sure we are still
getting ACS formatted data out:

 :commandoutput: mkplummer.rb -n 5 -s 1 | nbody_cst1.rb -d 0.001 -t 1 | head -10

*Bob*: As advertised!  Ready to move on.

== Estimating the Time Step Size

*Alice*: So far we've been using a constant value for the time step.
As long as we use softening, that is fine in most cases, at least if
we can make sure that particles all move with similar velocities.

*Bob*: Yes, we could rely on the fact that we had a natural time scale
_T_, given by the time needed for a particle with a typical velocity
to move over a distance equal to the softening length.  To keep our
integration accurate, all we had to do was to make sure that the time
step we used was a small fraction _f_ of _T_.

*Alice*: But even in that case, we could have run into trouble.  If any
particle were to move with a velocity large than the typical velocity
by a factor of more than 1/_f_, such a particle could cross a distance
more than the softening length within one time step.  Since the
gravitational potential, and hence the gravitational force, could
chance significantly over such a distance, such a large time step
would spell danger.  Already for this reason, it would be better to
use adaptive time steps, even if we were to use softening.

*Bob*: And for our main purpose, modeling dense stellar systems, we are
not interested in softening.  In our case, we are dealing with point
particles, for all practical purposes.  Only if stars approach each other
within a distance comparable to the sum of their radii, do we have to
take into account deviations from point-mass behavior.  That deviation,
if needed, will then be far more complex than adding a simple form of
Plummer softening.

*Alice*: And if we are dealing with encounters between neutron stars
and/or black holes, deviations from point-mass behavior will show up
only at tiny distances, of order a hundred kilometers or so.

*Bob*: So we'll leave softening for those folks who want to study
collisionless stellar dynamics, where by definition particle-particle
interactions are not considered to be of interest.  And yes, this means
that we will have to introduce an adaptive way to determine the time
step for each particle.

*Alice*: For starters, let us stick with a shared time step size, the same
for all particles at any given time, but variable over time.  What we need
to do, is to determine an estimate for the time scale _T_ over which
we can expect significant changes to occur in the system.  For the shared
but variable time step we can then simply use the product of _f_ and _T_,
where _f_ is a constant, with a small value that remains fixed during
a run, and _T_ is time dependent, and computed on the fly.

*Bob*: The most natural guess would be the time scale for collisions to
occur.  Even if particles are moving head-on toward each other, it will
take of order relative distance divided by relative velocity to hit
each other.  And if they move in different directions, the time scale
for significant changes in their relative position will still be given
by this ratio.

*Alice*: But what if the particles happen to move at roughly the same
velocity, in both magnitude and direction?  In that case your collision
time scale estimate will give much too large a number, in fact it will
produce infinity if the relative velocity is exactly zero.

*Bob*: Good point.  I guess we need to include another criterion as well.
How about a free fall timescale?  We can estimate the time it takes for
two particles to meet each other, starting at rest.  From dimensional
analysis it is clear that this time scale must be something like
relative distance squared divided by relative acceleration.

*Alice*: The square root of that quantity, you mean.

*Bob*: Ah, yes.  Well, let's code it up, and then we won't have any
ambiguity.  I'll copy the code <tt>nbody_cst1.rb</tt> into a new file
<tt>nbody_sh1.rb</tt>.  To start with, I'm going to get rid of all the
references to softening.  As we just discussed, there is no need to
bother with that extra complication once we have an adaptive time step
choice.  In addition, let me 
