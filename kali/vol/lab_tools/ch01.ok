= Quick Notes

== Moving precision and indentation and other options to acsio.rb

Now it's time to run a slew of simulations, rather than just one run.

How to automatize that?

Bob: automatize what?  I want to see a concrete example.

Alice: evaporation a la Casertano

Bob: takes too long.  How about first binary formation, then stop.

Alice: fine.

It would be nice to get the diagnostics inside the particle output data,
as is done with the story mechanism in starlab.

The problem is: now each class within world4.rb has the freedom to
report something: this means it will scribble that both in its own
story and it should also report this information to the output module,
somehow.  But if every class inside world4.rb is allowed to write
something in its own story, how will that class know what precision
and indentation to use?

Bob: let's pick fixed values for those.

Alice: baka.

Bob: well, global variables?

Alice: baka.

Bob: how else can we do it?

Alice: somehow, ascwrite should know about the options.

Bob: but that means building it in.

Alice: if the user could give that information to acs_write,
that would be great.  Ruby is interpreted after all, so the
information has to be available only by the time acs_write is being
used.

Here is the situation.  We have the clop function that reads the def
string from the user program, and that then parse the command line
options.  Now we want to add a default set of defs to the def string,
which determine precision, etc.  The only program that can know about
that, is acsio.rb.

However, we don't want to entangle clop.rb and acsio.rb.  We want to
be able to run clop.rb without acsio.rb present, and also we want to
be able to run acsio.rb without clop.rb present.

The way to do that is to give clop.rb the capability to add extra
defs to a given def string.  In other words, the previously static
def string now becomes a dynamic def string.  In this way, clop does
not have to know about precision or whatever is given as addition to
the def string.

Now for acsio.rb, we can define the additional defs there, but if the
class Clop is not defined, we won't use them, but instead we will use
the internal default values for precision, etc.

AHAHA: so far we have used the default precision of 16 as something
that was specified BOTH in acsio.rb AND in world1.rb, etc.

So we will succeed to keep clop and acsio independent.

Now how to do that?

Proc and block and lambda and trying out various things:

 class X
   @@plist=[]
 
   attr_reader :a
   def initialize(a)
     @a=a
     @@plist.each{|x| x.call(self)}
   end
   def X.register(x)
     @@plist.push x
   end
   def X.hellow
     print "Greetings from Mr. X \n"
   end
 end
 
 X.register(Proc.new{|x| print x.class, " hellow world!\n"})
 X.register(Proc.new{|x| x.class.hellow})
 X.register(Proc.new{|x| print "a=", x.a, "\n"})
 X.new(5)

Okay, this works, so let's implement it in the clop.rb file first,
by giving it the possibility to add definitions, in addition to those
that a user function has in its own definition string.

That works too, so then we go to acsio.rb and implement it there.

So now acsio.rb has four options that are included in any file that includes
acsio.rb: --precision, --indentation.

== verbosity

We could then use a
verbosity level which determines how much, if any, will appear on the
STDERR output.  By default we use "-v 1" which does what has been done
so far.  With "-v 0" you don't get any information.  With "-v 2", if
implemented, you'll get a lot of extra information; this is a type of
debug option.

Maybe a --acs_output_verbosity option also with default value 1,
which you can set to 0 or 2 if you want no or very much output in the
particle output file.

So now acsio.rb has four options that are included in any file that includes
acsio.rb: --verbosity, --acs_verbosity, --precision, --indentation.

So we need a method in the ACS_IO module which recieves two parameters,
a string that contains a form of internal output (like a virtual output),
and the verbosity number.  Hmmm.  The options precision and indentation
can and should also be treated automatically.  How to do that?

== writing to particle/whatever "stories"

Note: for now we will violate the DRY principle, by having at the top
of <tt>module ACS_IO</tt> the following list:

  @@add_indent = 2
  @@precision = 16
  @@verbosity = 1
  @@acs_verbosity = 1

even though these same values appear in the additional defs at the end
of the acsio.rb file.  You could argue that this list presents the
values used if NO clop method is used, and that therefore IF you use
the clop, you override those and you can forget about them.  This is
the price we pay by having no entanglement between clop and acsio.rb

You _could_ argue, however, as a very fine point, that IF clop is
present, it would be most ideal if it would set the default values
of its additional defs equal to the default values that would be used
if NO clop would be present.  But this is such a fine point that we
will leave it as an exercise for the reader.

One problem: we have written clop.rb in such a way that we could have
more than one clop object.  However, the function <tt>Clop.add_defs</tt>
works only for a singleton Clop class with only a single instance.
The problem arises from the fact that we address this object by using
class variables, of which there is only one set.
So the problem of the problem is: we don't know whether this is a problem.
For now, let's just move ahead.

Now what to do with story output?  If you let stories grow, then each
particle output will put out more story items, and the number of story
items printed will grow quadratically.  Solution: let acs_write erase
a story immediately after it is printed.  You can circumvent this
behavior, for example when you are debugging and want to keep the
complete story, but making a backup pointer just before each acs_write,
and restoring the story immediately afterwards from that pointer.

