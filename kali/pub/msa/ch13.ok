= A Complete +Vector+ Class

== +Vector+ Subtraction

*Erica*: Well, Carol, you've pulled a really neat trick.  What a difference,
being able to add vectors by writing

  v = v1 + v2

rather than 

  v = []
  v1.each_index{|k| v[k] = v1[k] + v2[k]}

*Dan*: Thanks, Carol!  You've just made our life a whole lot easier.

*Carol*: Not quite yet; I'll have to do the same thing for subtraction,
multiplication and addition as well.  And I'm sure there are a few more
things to consider, before we can claim to have a complete +Vector+ clss.
But I, too, am encouraged with the good start we've made!

I'll open a new file <tt>vector_try_add_sub.rb</tt>.  First thing to add,
after addition, is subtraction.  That part is easy:

 :inccode: .vector_try_add_sub.rb

*Erica*: So now we can write <tt>v = v1 + v2</tt> and <tt>v = v1 - v2</tt>
But what about <tt>v = -v1</tt>?  Or even just <tt>v = v1</tt>?  Would that
work too?

*Carol*: Good question!  Probably not.  But before getting into the why not,
let's play with +irb+ and see what happens:

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

x

<b>[Jun, here is the original irb output of an irb session that I ran first
and then just pasted as straight text into the chapter: -- Piet]</b>

  |gravity> irb
  irb(main):001:0> require "vector_try_add_sub.rb"
  => true
  irb(main):002:0> v1 = Vector[1, 2, 3]
  => [1, 2, 3]
  irb(main):003:0> v2 = Vector[5, 6, 7]
  => [5, 6, 7]
  irb(main):004:0> v = v1 + v2
  => [6, 8, 10]
  irb(main):005:0> v = v1 - v2
  => [-4, -4, -4]
  irb(main):006:0> v = v1
  => [1, 2, 3]
  irb(main):007:0> v = -v1
  NoMethodError: undefined method `-@' for [1, 2, 3]:Vector
          from (irb):7

<b>[Jun, clearly it would be much better to actually run irb when we
compile this chapter.  So I'm repeating the same session now below with
an actual command, using ":commandinputoutput:". The problem is: we
don't want to see the initial echo of all the input commands.
How shall we solve this? --  Piet]</b>

 :commandinputoutput: irb END
require "vector_try_add_sub.rb"
v1 = Vector[1, 2, 3]
v2 = Vector[5, 6, 7]
v = v1 + v2
v = v1 - v2
v = v1
v = -v1
END

<b>[Jun, this is the end of the irb experiment area -- Piet]</b>

*Dan*: Huh?  A method by the name of a minus sign followed by an
<tt>@</tt> symbol?  That's the strangest method name I've ever seen.
And what can it mean that it is undefined?  Should it be defined?

*Erica*: At least writing <tt>v = v1</tt> worked.  So we've come halfway!

*Dan*: Ah, but would it also work if we would write <tt>v = +v1</tt>?
Let me try:

  |gravity> irb
  irb(main):001:0> require "vector_try_add_sub.rb"
  => true
  irb(main):002:0> v1 = Vector[1, 2, 3]
  => [1, 2, 3]
  irb(main):003:0> v2 = Vector[5, 6, 7]
  => [5, 6, 7]
  irb(main):004:0> v = +v1
  NoMethodError: undefined method `+@' for [1, 2, 3]:Vector
          from (irb):4

Aha!  You see, we're not even half-way yet.  Neither of the two work.
But it's intriguing that we get a similar error message, this time with
a plus sign in front of the mysterious <tt>@</tt> symbol.

== Unitary <tt>+</tt> and <tt>-</tt>

*Carol*: Let me consult the Ruby manual.  Just a moment . . . aha, I see!
Well, this is perhaps an exception to Ruby's principle of least surprise.



<b>[ this is how far I got ; 2007/7/28 -- Piet ]</b>

== +Vector+ Multiplication

multiplication.

In fact, there are two types of multiplication that we have to consider.

With <tt>vector_try.rb</tt>: 

 :inccode: .vector_try.rb

And with <tt>euler_modified_vector_try.rb</tt>:

 :inccode: .euler_modified_vector_try.rb

 :commandoutput: ruby euler_modified_vector_try.rb | tail -1

With <tt>euler_modified_vector_try_again.rb</tt>:

 :inccode: .euler_modified_vector_try_again.rb

 :commandoutput: ruby euler_modified_vector_try_again.rb | tail -1

Now with <tt>vector.rb</tt>: 

 :inccode: .vector.rb

And with <tt>euler_modified_vector.rb</tt>:

 :inccode: .euler_modified_vector.rb

 :commandoutput: ruby euler_modified_vector.rb | tail -1

Let integer division give floating point results, where needed
