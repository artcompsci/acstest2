= A Puzzle

== Yoshida

*Bob*: We can now put our distance measurement tool to good use, by
testing whether our shared time step integrator really does the right
thing.
We'll do a test run with the constant time step code first,
and then compare the results with that from the shared time step
code.

*Alice*: Let's take an unusual integrator.  How about Yoshida's fourth order
scheme?

*Bob*: As you wish.  And while we're at it, let's check whether the scheme
is still fourth order, in constant as well as shared time step form.  First
I'll prepare initial conditions with the particles all properly numbered:

 :commandoutput: ruby mkplummer.rb -n 4 -s 1 | ruby nbody_set_id.rb > test.in

Starting with the constant time step version, let's choose the
<tt>yo4</tt> integrator, but what options did we use for algorithm
choice?  I always forget what names we gave our options.  Let's ask
our clop function to provide them:

 :commandoutput: ruby nbody_cst1.rb -h

== Energy Scaling

Aha, now I remember.  Okay, how about this?

 :commandoutput: ruby nbody_cst1.rb -g yo4 -t 1 < test.in > yo4cst.out

Now let's make the time step twice as big:

 :commandoutput: ruby nbody_cst1.rb -g yo4 -t 1 -c 0.002 < test.in > yo4cst_twice.out

== Phase Space Distance Scaling

*Alice*: Indeed, fourth order.  Very close to a factor <tex>$2^4=16$</tex>
difference.  But before we go further, and use our shared time step
integrator, let's first see whether in this case the distance
in phase space also scales like the fourth power in the time step.

*Bob*: Ah, yes, good idea.  But in order to do so, we have to know what the
`true' solution is.  When we check energy conservation, we know that a
truly accurate integration would give us an energy error of zero, but when
we compare the two outputs we just got, we need to compare them to an even
more accurate soluation.  Well, we can run our code with a much smaller
time step, and declare that the result should be close to `true'.  Or to
speed things up a bit, we can take a higher-order integrator.  Why not
throw the sixth-oder Yoshida version in, to help us:

 :commandoutput: ruby nbody_cst1.rb -g yo6 -t 1 < test.in > yo6cst.out

First we'll compare the first run with the `true' run:

 :commandoutput: cat yo4cst.out yo6cst.out | ruby nbody_diff.rb

And then we'll take the second run, to compare it with the `true' one:

 :commandoutput: cat yo4cst_twice.out yo6cst.out | ruby nbody_diff.rb

*Alice*: Very nice indeed, almost exactly a factor 16 bigger.

== The Shared Time Step Code

*Bob*: After all these preliminaries, we can finally test our shared time
step code:

 :commandoutput: ruby nbody_sh1.rb -g yo4 -t 1 < test.in > yo4sh.out

Not terribly accurate.  Let's half the step size:

 :commandoutput: ruby nbody_sh1.rb -g yo4 -t 1 -c 0.005 < test.in > yo4sh_half.out

That's better, and comparable to the accuracy that we got with the default
time step size for <tt>nbody_cst1.rb</tt> while using Yoshida's fourth-order
integrator.  Let's see whether we're getting equally close to the `true'
run in phase space:

 :commandoutput: cat yo4sh_half.out yo6cst.out | ruby nbody_diff.rb

*Alice*: What is that?!?

*Bob*: That sure doesn't look good.  How can the distance be so large?

== Back to Basics

*Alice*: Could it be that Yoshida's integrator is just too fancy for our
purpose?  Perhaps that was not such a good choice to start our testing
with.  Let's go back to basics, and do the same thing with the leapfrog
integrator instead:

 :commandoutput: ruby nbody_sh1.rb -g leapfrog -t 1 < test.in > leap_sh.out
 :commandoutput: ruby nbody_sh1.rb -g leapfrog -t 1 -c 0.001 < test.in > leap_sh_tenth.out

*Bob*: The energy scales like it should for a second-order integrator:
a hundred times better accuracy for a ten times smaller time step.

*Alice*: And, really, the phase space distance should also become a
hundred times better.  I hope it does:

 :commandoutput: cat leap_sh.out yo6cst.out | ruby nbody_diff.rb
 :commandoutput: cat leap_sh_tenth.out yo6cst.out | ruby nbody_diff.rb

== Even more Basic

*Bob*: Well, it doesn't.  What is going on here?

*Alice*: Let's completely forget about fourth-order integrators, and
stick to the basics completely.  If we do a third leapfrog integration,
we can use the result of that run as our yard stick:

 :commandoutput: ruby nbody_sh1.rb -g leapfrog -t 1 -c 0.0001 < test.in > leap_sh_hundredth.out
 :commandoutput: cat leap_sh.out leap_sh_hundredth.out | ruby nbody_diff.rb
 :commandoutput: cat leap_sh_tenth.out leap_sh_hundredth.out | ruby nbody_diff.rb

*Bob*: That doesn't make much difference.  Still no quadratic behavior.

*Alice*: No matter what we do, we get a behavior that is closer to linear
than quadratic.

*Bob*: That should tell us something.  But what?

*Alice*: Beats me.

*Bob*: This is ennoying.  Just when we were having fun!

*Alice*: How about a cup of tea first?

*Bob*: Feel free to get some tea, but I'll stay here.  I just can't stand
this.  What could be going so terribly wrong here?
