= Second-Order Integration Algorithms

== The Modified Euler Algorithm

*Dan*: Well, Erica, how are we going to move up to a more accurate
algorithm?

*Carol*: You mentioned something about a second-order scheme.

*Erica*: Yes, and there are several different choices.  With our
first-order approach, we had little choice.  Forward Euler was the
obvious one: just follow your nose, the way it is pointed at the 
beginning of the step, as in fig. ref(forward1).

*Dan*: You mentioned a backward Euler as well, and even drew a picture,
in in fig. ref(backward1).

*Erica*: That was only because you asked me about it!  And the backward
Euler scheme is not an explicit method.  It is an implicit method, where
you have to know the answer before give calculate it.  As we discussed, you
can solve that through iteration, but then you have to take every step
twice, and you still only have a first-order method, so there is no good
reason to use that method.

*Dan*: But wait a minute, the two types of errors in figs. ref(forward1)
and ref(backward1) are clearly going in the opposite directions.
I mean, forward flies out of the curve one way, and backwards spiral in
the other way.  I wonder, can't you somehow combine the two methods and
see whether we can let the two errors cancel each other?

:figure: modforward1.eps 6cm modforward1
An attempt to improve the Euler methods.  The top arrow shows forward Euler,
and the bottom arrow backward Euler.  The dashed arrow shows the average
between the two, which clearly gives a better approximation to the curved
lines that show the true solutions to the differential equation.

:figure: modforward2.eps 6cm modforward2
Two successive forward Euler steps.

:figure: modforward3.eps 6cm modforward3
A forward Euler steps and a backward Euler step, landing at the same point.

If we combine the previous two pictures, the most natural thing would be
to try _both_ of the Euler types, forward and backward.  Here is a sketch,
in fig. ref(modforward1).  The top arrow is what we've done so far,
forward Euler, simply following the tangent line of the curve.  The
bottom line is backward Euler, taking a step that lands on a curve
with the right tangent at the end.  My idea is to compute both, and then
take the average between the two attempts.  I'm sure that would give a
better approximation!

*Carol*: But at a large cost!  The backward Euler method is an implicit
method, as Erica mentioned, that requires at least one extra iteration.
So the bottom arrow alone is much more expensive to compute than the top
arrow, and we have to compute both.

*Erica*: You are both right.  Dan's idea was brilliant!  Dan, were you
reading my mind?  What you proposed was the essential idea behind what
is called the modified Euler method.  And Carol hinted at the missing
piece.  Instead of computing both forward and backward right at the
start, it is more efficient to begin with a forward Euler step, and
then to compute the backward Euler step at the position where the forward
step landed.

Here, let me also draw a picture, in fig. ref(modforward2).  Here we
take one forward Euler step, and we then compute a second forward Euler
step, following the first one.  If we now shift the second arrow back,
so that the end of the arrow falls on the same point as the end of the
first arrow, we have constructed a backward Euler step that lands on the
same point where our forward Euler step landed, as you can see in
fig. ref(modforward3).

Of course, the top arrow in fig. ref(modforward3) is not exactly the
same arrow as the bottow arrow in fig. ref(modforward1), but the two
arrows are approximately the same, especially if our step sizes are
not too large.  So, in a first approximation, we can average the arrows
in fig. ref(modforward3).  This will make Carol happy: no more implicit
steps.  We have only taken forward steps, even though we recycle the
second one by interpreting it as a backward step.

:figure: modforward4.eps 6cm modforward4
The modified Euler approximation is indicated by the lower arrow, as
the average of the forward and backward Euler methode.  The
curved lines show the true solutions to the differential equation.

The simplest way to construct the average between the two vectors is by
adding them and then dividing the length by two.  Here it is, in fig.
fig. ref(modforward4).

*Dan*: Well, I don't know what hit me, but I'm glad my idea was useful!

*Erica*: What I've just drawn here has a name.  In the literature on
numerical solutions to differential equations it is called the
modified Euler method.  Modified in the sense of starting with forward
Euler, and then modifying it by taking backward Euler into account as
well.

== Implementation

*Carol*: It should be easy to implement this new scheme.  The picture
we have drawn shows the change in position of a particle, and we
should apply the same idea to the change in velocity.

For starters, let us just look at the position.  First we have to
introduce some notation.

*Erica*: In the literature, people often talk about predictor-corrector
methods.  The idea is that you first make a rough prediction about a
future position, and then you make a correction, after you had
evaluated the forces at that predicted position.

In our case, in fig. ref(modforward4), the first solid arrow starts at
the original point <tex>$\br_i$</tex>.  Let us call the end point of that
arrow <tex>$\br_{i+1, p}$</tex>, where the _p_ stands for _predicted_,
as the predicted result of taking a forward Euler step:

:equation:
\br_{i+1, p} = \br_i + \bv_i dt

The second arrow shows another prediction, namely for yet another
forward Euler step, which lands us at <tex>$\br_{i+2, p}$</tex>:

:equation:
\br_{i+2, p} = \br_{i+1, p} + \bv_{i+1, p} dt

*Dan*: But here you are using the velocity at time <tex>$i+1$</tex>,
something that you haven't calculated yet.

*Erica*: I know, we'll come to that in a moment.  I just wanted to write
the position part first.

We can find the _corrected_ new position by taking the average of the
first two forward Euler steps, as indicated in fig. ref(modforward4):

:eqnarray:
\label{ModEulerStepLong}
\br_{i+1, c} & = & \br_i + 
\half\left\{\left(\br_{i+1, p} - \br_i\right)+
           \left(\br_{i+2, p} - \br_{i+1, p}\right)\right\}    \nonumber \\
& = & \br_i + \half\left(\br_{i+2, p} - \br_i\right)           \nonumber \\
& = & \half\left(\br_i + \br_{i+2, p}\right)

*Carol*: As Dan pointed out, we have to do a similar thing for the velocities.
I guess that everything carries over, but with <tex>$\bv$</tex> instead
of <tex>$\br$</tex> and <tex>$\ba$</tex> instead of <tex>$\ba$</tex>.

*Erica*: Yes, in fact it is just a matter of differentiating the previous
lines with respect to time.  Putting it all together, we then get:

:eqnarray:
\label{ModEulerStep}
\br_{i+1, p} & = & \br_i + \bv_i dt                           \nonumber \\
\bv_{i+1, p} & = & \bv_i + \ba_i dt                           \nonumber \\
\br_{i+2, p} & = & \br_{i+1, p} + \bv_{i+1, p} dt             \nonumber \\
\bv_{i+2, p} & = & \bv_{i+1, p} + \ba_{i+1, p} dt             \nonumber \\
\br_{i+1, c} & = & \half\left(\br_i + \br_{i+2, p}\right)     \nonumber \\
\bv_{i+1, c} & = & \half\left(\bv_i + \bv_{i+2, p}\right)

== xxx

Here is 

<tt>euler_modified_1000_sparse.rb</tt>:

 :inccode: .euler_modified_1000_sparse.rb

Try:

 :commandoutput: ruby euler_modified_1000_sparse.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "euler_modified_1000_sparse.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_modified_1000_sparse.ps 10cm euler_modified_1000_sparse
First attempt at modified Euler integration, with stepsize
<tex>$dt=0.001$</tex>.

Wow!!!  Too good to be true.  Let's try 10 times later steps.

== xxx

Here is 

<tt>euler_modified_100.rb</tt>:

 :inccode: .euler_modified_100.rb

Try:

 :commandoutput: ruby euler_modified_100.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "euler_modified_100.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_modified_100.ps 10cm euler_modified_100
Second attempt at modified Euler integration, with stepsize
<tex>$dt=0.01$</tex>.





== xxx

== leapfrog

*Carol*: Erica, what kind of second-order algorithm should we use,
to replace our first-order forward Euler scheme?

*Erica*: A nice and simple scheme is the _leapfrog_ algorithm.

*Dan*: What a strange name.  Does it let particles jump around like frogs?

*Carol*: Or like children jumping over each other?

*Erica*: Something like that, I guess.  I never thought about the meaning
of the name.  It is used quite widely, although it has different names in
different fields of science.  In stellar dynamics you often hear it called
leapfrog, but in molecular dynamics it is generally called the Verlet
method, and I'm sure there must be other names in use in other fields.

Here is the idea:

:eqnarray:
\br_{i} & = & \br_{i-1} + \bv_{i-1/2} dt \label{leapfrog-leap-step1} \\
\bv_{i+1/2} & = & \bv_{i-1/2} + \ba_i dt \label{leapfrog-leap-step2}

== xxx

== xxx

Here is 

<tt>leapfrog_100.rb</tt>:

 :inccode: .leapfrog_100.rb

Try:

 :commandoutput: ruby leapfrog_100.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "leapfrog_100.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: leapfrog_100.ps 10cm leapfrog_100
First attempt at leapfrog integration, with stepsize <tex>$dt=0.01$</tex>.







<b>* * * * * * *  This is how far I got, 2007/5/19  * * * * * * * </b>

