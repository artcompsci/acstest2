= Debugging the Code

== One Integration Step: Verification

*Carol*: This is about the simplest thing we could possibly do,
for the one-body problem: starting with a circular orbit, and then
taking only one small step.  Here we go . . .

 :commandoutput: ruby euler_circular_step.rb

*Dan*: . . . and getting just one short new line of output, after
the initial conditions are echoed.  But it seems too simple!
Previously, we got much more complicated lines of output.

*Carol*: Well, yes, but did we got those right away?  Let me check.
Good thing we kept the old program, and give the new one a new name.
Let me reproduce the first four lines of the old program:

 :commandoutput: ruby euler.rb | head -4

*Dan*: I see, I was wrong.  The first step gave a simple answer,
also in the previous case; it was after the second step that rather
complicated numbers showed up.

But what are these extra lines, with error messages?

*Carol*: Oh, that is just Ruby being too sensitive, or Unix being too
rude, as you like.  The Unix +head+ command just breaks the pipe after
reading the first four lines, without cleaning up properly, and Ruby
complains about that.

*Dan*: Good, so we can ignore that then.

*Erica*: Time to check whether our first step is correct!  We start
with

:equation:
\br(0) = \{x, y, z\} = \{1,0,0\}

and

:equation:
\bv(0) = \{v_x, v_y, v_z\} = \{0,1,0\}

so the new position must be:

:equation:
\br(dt) = \br + \bv dt = \{1,dt,0\}

*Carol*: And this is indeed what we see in the first half of the second
output line.

*Dan*: Yes, in both cases: for our new one-step program we got the correct
result with <tt>v=1</tt> and for our old program we got the correct result
with <tt>v=0.5</tt>, given that in both cases we choose <tt>dt=0.01</tt>.
That is encouraging!

Now what about the second half of the second output lines?

*Erica*: To compute the new velocity, we have to first compute the
acceleration vector.  We can use Eq. (ref(Newton2bodysimple)), which
I'll copy here once again:

:equation:
\ba = - \frac{\br}{r^3}

In our case this gives

:equation:
\ba = \{a_x, a_y, a_z\} = \{-1,0,0\}

And this in turn means that

:equation:
\bv(dt) = \bv + \ba dt = \{-dt,1,0\}

*Carol*: And this is indeed what is printed in the last half of the last
output line, in our one-step program.  For our previous program, we have
to remember that the initial velocity was only half as large, which gives
<tex>$\bv(dt) = \{-dt,0.5,0\}$</tex> which is indeed what we got.

*Dan*: Perfect.

== One Integration Step: Validation

*Carol*: Well, sort-of.  We have verified that our program does what the
algorithm intended, and that is certainly nice!  But this is only half
of the work.  We now have to check whether this particular algorithm
does indeed give a reasonable result, which corresponds to the behavior
of gravitating particles in the real world.  This is called validation.
In the computer science literature these two checks are often called 
V&V, for Verification and Validation.

In other words, we have passed the verification test.  The computer
code does exactly what we wanted it to do, at least for one step.  But
now we have to do a validation test.  For example, we can ask whether
this first step keeps the two particles on a circular orbit.  After
the first step, the new separation is:

:equation:
\label{first_step_error}
r(0.1) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.01^2} = 
\sqrt{1.0001} \approx 1.00005

*Dan*: Instead of the correct value of <tex>$r(0.01)=1$</tex>, we are half a
one hundredth of one percent off.  Not bad, I would say.

*Carol*: Not bad for one step, perhaps, but our orbit has a radius of unity,
which means a circumference of <tex>$2\pi \approx 6.3$</tex>.  With a velocity
of unity, it will take <tex>$630$</tex> steps to go around the circle,
at the rate we are going.  And if every step introduces `only' an
error of <tex>$0.00005$</tex>, and if the errors built up linearly, we
wind up with a total error of <tex>$1 + 630*0.00005 \approx 1.03$</tex>.
That is already a 3% error, even during the first revolution!  And after
just a few dozen revolutions, if not earlier, the results will be meaningless.

*Dan*: Good point.  Of course, we don't know whether the errors build up
linearly, but for lack of a better idea, that would be the first guess.
Perhaps we should take an even smaller time step.  What would happen
if we would use <tex>$dt = 0.001$</tex>?  Let's repeat your analysis.
After one step, we would have

:equation:
r(0.001) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.001^2} = \sqrt{1.000001}
\approx 1.0000005

We now need roughly <tex>$6300$</tex> steps to go around the circle,
If the errors build up linearly, the radial separation will grow to
something like <tex>$1 + 6300*0.0000005 \approx 1.003$</tex>.  Aha!  Only
a 0.3% error, instead of 3%.

*Erica*: Bravo!  You have just proved that the forward Euler scheme is
a first-order scheme!  Remember our discussion at the start?  For a
first-order scheme, the errors scale like the first power of the time
step.  You just showed that taking a time step that is ten times smaller
leads to a ten times smaller error after completing one revolution.

*Dan*: Great!  I thought that numerical analysis was a lot harder.

*Carol*: Believe me, it _is_ a lot harder for any numerical integration
scheme that is more complex than first-order.  You'll see!

*Dan*: I can wait.  For now I'm happy to work with a scheme which I can
completely understand.

== More Integration Steps

*Carol*: So were are we.  To sum up: we have verified that our
simple one-step code <tt>euler_circular_step.rb</tt> does exactly what
we want it to do.  And we have validated that what we want it to do is
reasonable: for smaller and smaller time steps the orbit should stay
closer and closer to the true circular orbit.

*Dan*: That's the good news.  But at the same time, that's also the bad
news!  When we tried to integrate an arbitrary elliptical orbit, we got
a nonsense picture.  So then we tried to make life simpler, to see what
went wrong.  But we have not found anything that went wrong!  How come?

*Erica*: We'll have to work our way up to the more complicated situation.
Let us stick to the circular orbit for now.  We have a basis to start from:
the first step was correct, that we know for sure.  Let's do a few more steps.

*Dan*: How about a hundred steps?

*Erica*: Why not.  Let us go back to the very first code we wrote, but
now for a circular orbit, and for an integration of one time unit, which
will give us a hundred steps.

*Carol*: Let's keep the old code, for comparison.  Here is the new one.
I will call it <tt>euler_circular_100_steps.rb</tt>:

 :inccode: .euler_circular_100_steps.rb

*Dan*: If you keep making the names longer and longer, they won't fit on
a single line anymore!

*Carol*: You do what you want and I do what I want; I just happen to sit
behind the keyboard.

*Erica*: Peace, peace!  Let's not fight about names; we can later make
copies with shorter names as much as we like.

 :commandoutput: ruby euler_circular_100_steps.rb > euler.out

 |gravity> gnuplot
 gnuplot> set size ratio -1
 gnuplot> plot "euler.out"
 gnuplot> quit

 :command: ruby euler_circular_100_steps.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "euler_circular_100.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_circular_100.ps 10cm euler_circular_100
Second attempt at integrating the two-body problem: a quarter circle?

*Dan*: Figure ref(euler_circular_100) is still too good to be true;
looks like the orbit is perfectly circular, as far as the eye can see.
We're supposed to find a bug, but everything just keeps going fine.
We have a problem, in that we don't find a problem!

*Erica*: the orbit is round all right, but look where it is centered on!

*Dan*: It is centered on the point on the _x_ axis close to the left of
the figure, something like <tex>$\{0.5, 0\}$</tex>.  What's wrong with
that?  The two particles are supposed to go around each other.  After
another 100 steps our second particle will presumably wind up at
<tex>$\{0, 0\}$</tex>.

*Carol*: No, no, no, Carol is right, this is wrong!

*Dan*: I beg your pardon?

*Carol*: We have reduced the two-body problem to a one-body problem,
remember?  What we are plotting is the relative distance between the
two particles.  If the relative distance vector would ever become
<tex>$\{0, 0\}$</tex>, that would mean that the two particles would
sit on top of each other . . . 

*Dan*: . . . rather than going around each other at a constant distance
of one.  Yes, how stupid of me!

*Erica*: Well, it's easy to get confused, when getting into orbital
mechanics.  If I were to tell you of all my past stupidities . . . 

*Carol*: . . . please don't!  Better to follow the trail of the bug
we've found.  How about some more steps?

== Even More Integration Steps

*Erica*: Let's try to be more systematic.  We tried one step, and then
we tried a hundred steps.  But our very first problem showed up after
a thousand steps.  I'd like us to try a thousand steps here too.

*Carol*: Let's make yet another new file . . . Dan,
close your eyes, I'm adding one more
character to the file name . . . <tt>euler_circular_1000_steps.rb</tt>:

 :inccode: .euler_circular_1000_steps.rb

*Dan*: no comment.

*Carol*: And here is our new result, which I'm calling
figure ref(euler_circular_1000):

 :commandoutput: ruby euler_circular_1000_steps.rb > euler.out

 |gravity> gnuplot
 gnuplot> set size ratio -1
 gnuplot> plot "euler.out"
 gnuplot> quit

 :command: ruby euler_circular_1000_steps.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "euler_circular_1000.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_circular_1000.ps 10cm euler_circular_1000
Third attempt at integrating the two-body problem: another failure.

*Dan*: Whoa, no more circle here!!

*Erica*: I'd say!

*Carol*: That's awesome!  How easy it is to get misled.  After one
hundred steps of almost circular motion, the orbit changes into an
almost straight line, and then suddenly all hell breaks loose, and
the relative distance grows again as if somebody used a slingshot!

*Dan*: Well, that last part is similar to the original bug we had,
with our first attempt at integrating an elliptical orbit.  But this
looks different.  In our first attempt the orbit seemed to be flying
off the tracks, but here there seems to be a repelling force, somehow.

*Carol*: More likely we are just dealing with some form of numerical
mistake or numerical instability.  I wouldn't assign any physical
meaning to it, until we have really understood what is happening.

*Erica*: I agree.  The question is how to get this real understanding!
I must admit that I'm baffled.

== Code Inspection

*Carol*: Well, that is where you new a computer scientist to come in.
We are supposed to be trained to do trouble shooting and bug chasing.

*Dan*: But this is such a short program, it must be possible to inspect
each line to see what is wrong.

*Erica*: Even short programs can be misleading.  Once you gloss over a
subtle mistake, you can read it as often as you want, and chances are
that upon each reading you will overlook it again.

*Dan*: The first line is correct.  Clearly.  The second line is correct . . .

*Carol*: I completely agree with Erica.  That's not the way to do it, Dan.

*Dan*: . . . the sixth line is correct.  Clearly.  The seventh line is
correct . . .

*Erica*: Let's leave him looking at tea leaves.  Carol, show me how you
use that wonderful training of yours.

*Dan*: . . . the eleventh line is correct.  Clearly.  The twelfth line is
correct . . .

*Carol*: To start with, I will draw a flow diagram.

*Erica*: A flow diagram?  There is not much to flow in such a short program.

*Dan*: . . . the eighteenth line is correct.  Clearly.  The nineteenth line is
correct . . .

*Carol*: Short or not, let's be formal here.  I will draw this box . . .

*Dan*: Yeahhh!!!

*Erica*: Yeah what?

*Dan*: The twenty-first line!

*Carol*: The twenty-first line what?

*Dan*: The bug is in the twenty-first line!  Clear, for all to see!
Here let me print line twenty, twenty-one and twenty-two:

 :inccode: .euler_circular_1000_steps.rb-1

*Erica*: Dan's right.  That second +ax+ should be +ay+.

*Carol*: You're right!  He's right.  How simple.

*Dan*: Sometimes it helps to have no training.

*Erica*: I guess so!  What a trivial mistake.  Just a little typo!

*Dan*: But one with large consequences.

*Carol*: Well, Dan, congratulations.  In this case, at least, your
brute force approach won out.  But that won't happen with much more
complex programs, I assure you.

*Dan*: We'll see.

*Carol*: In any case, okay, I've corrected the mistake.  I want to keep
the old file, so I'll call the corrected file simply
<tt>euler_circular.rb</tt>.

*Dan*: Yeah again, a shorter name!  Thank you.

*Carol*: Just to make you even happier.  Here are the new three lines:

 :inccode: .euler_circular.rb-1

*Dan*: I'm sure all will be well now.

*Erica*: I hope so!  Carol, how about giving it another try?
