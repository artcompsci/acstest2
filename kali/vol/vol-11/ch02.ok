= xxx

== xxx

*Bob*: Here is a quick and dirty version that I cobbled together, following
the recipe described in the paper <i>A comparison of Numerical Methods
for the Study of Star Cluster Dynamics</i>, by Sverre Aarseth, Michel Henon,
and Roland Wielen, which appeared ages ago, in 1974, in Astron. Astroph. 
<b>37</b>, 183.

*Alice*: I remember reading that paper as a student.

*Bob*: You are _that_ ancient?

*Alice*: Not quite.  I had just started high school.  I mean that I read it
as an undergraduate when I wanted to do a small N-body project for my
final thesis.  My advisor recommended it.  And indeed, it was an
influential paper by some of the masters in the field, around that time.

I remember it well: the paper made the first detailed quantitative comparison
between the Monte-Carlo Fokker-Plank method and direct N-body integration.
They even showed the results for runs with a few hundred particles.
Hard to believe that they got so much compute done, given the slow speed
of computers at that time.

*Bob*: That is impressive, given that computers have increased their speed
by a factor ten every five years or so.  That means that in 2004 computers
are a million times faster than what they had available.  I bet that my
camera is a lot more powerful than the computers in their university centers.

*Alice*: And I'm sure your camera has way more storage as well.  But
what was actually most impressive was how much information they were
able to squeeze out of their calculations, given their limited
resources.  Anyway, why did you bring up this paper?

*Bob*: Because it contains a nifty recipe for constructing a Plummer's model.

*Alice*: Hey, I didn't remember that.  Really?

*Bob*: They wrote it as an appendix.  Everything was done analytically, except
for the fact that they used a rejection technique at the last step, to
get the velocities.

*Alice*: I must not have looked at the appendix.  Well, that is convenient.
Can you show me your code?

*Bob*: Here it is, and I warned you, I haven't commented it or cleaned it up:
I just translated their recipe straight from the appendix into Ruby.

== A first Stab

 :inccode: .mkplummer1.rb-toriaezu

== xxx

== xxx

*Alice*: Can you tell me what their recipe was, and how you implemented it?

*Bob*: My pleasure.  They start by choosing a coordinate system in which
the total mass _M_, the gravitational constant _G_ and the structural length
scale _a_ that we used above are all unity.  The mass enclosed within
a radius _r_ then becomes:

:equation:
m(r) \, = \, \left(1+{1\over r^2}\right)^{-3/2}
     \, = \, r^3\left(r^2 + 1\right)^{-3/2}

When we construct a realization of Plummer's model, each particle will
be drawn randomly from Plummer's mass distribution.  This means that
the chance for a particle to lie in a mass shell between <tex>$r$</tex>
and <tex>$r+dr$</tex> is simply proportional to
<tex>$m(r+dr)-m(r)=dm(r)$</tex>, the mass enclosed within that shell.
In other words, we can pick a random number between <tex>$m(0)$</tex>
and <tex>$m(\infty)$</tex>, and with that random value <tex>$m_{rand}$</tex>
we can put our particle at the radius <tex>$r(m_{rand})$</tex> that
corresponds to that mass shell.  In other words, we have to invert the
<tex>$m(r)$</tex> relationship, giving the mass enclosed within a
given radius, in order to find the radius <tex>$r(M)$</tex> within which
a given amount of mass is enclosed.

*Alice*: That should not be too difficult.  From the equation above, it
follows that

<tex>$$
m(r) \, = \, r^3\left(r^2 + 1\right)^{-3/2} \, \Rightarrow \,
$$</tex>

<tex>$$
\left\{m(r)\right\}^{-2/3} \, = \, r^{-2}\left(r^2 + 1\right) \, \Rightarrow \,
$$</tex>

<tex>$$
r^2\left\{m(r)\right\}^{-2/3} \, = \, \left(r^2 + 1\right) \, \Rightarrow \,
$$</tex>

<tex>$$
r^2\left(\left\{m(r)\right\}^{-2/3}-1\right) \, = \, 1  \, \Rightarrow \,
$$</tex>

<tex>$$
r(m) \, = \, \left(m^{-2/3}-1\right)^{-1/2}
$$</tex>

*Bob*: this is indeed how I determined the radius, in the following line:

 :include: .mkplummer1.rb-4

Here a call to +rand+ gives us a random floating point number between 0 and 1,
which is just want we want for our mass shell, that contains a random amount
of matter, between 0 (in the center) and 1 (at infinity), given that we have
normalized the total amount of mass in our model to <tex>$M=1$</tex>.

*Alice*: So now that you have chosen the radial position of your particle,
you can assign random values to the usual spherical coordinates
<tex>$\theta$</tex> and <tex>$\phi$</tex>.  The latter is easy, since any
azimuthal angle <tex>$\phi$</tex> is equally likely, by spherical symmetry.
To pick a random value for <tex>$\theta$</tex>, however, we have to make
sure that the spherical integration element <tex>$\sin\theta d\theta$</tex>
gets an equal weight for any <tex>$\theta$</tex> value.  In other words,
any value for <tex>$d\left(\cos\theta\right)$</tex> is equally likely.

*Bob*: Yes, and the highest and lowest values occur for <tex>$\theta=0$</tex>,
along the positive _z_ axis, and for <tex>$\theta=\pi$</tex>, along
the negative _z_ axis.  <tex>$\cos\theta$</tex> thus runs from <tex>$+1$</tex>
to <tex>$-1$</tex>.  All we have to do is to pick a floating point
number at random, somewhere in the interval <tex>$\{-1, +1\}$</tex>.
I have done that in the following line:

 :include: .mkplummer1.rb-5

Here I have adapted the Ruby defined random number call +rand+ in the
following way, by defining a general floating point version +frand+:

 :inccode: .mkplummer1.rb+frand

Since +rand+ returns a value uniformly distributed throughout the
range <tex>$\{0, 1\}$</tex>, <tt>frand(a,b)</tt> returns a value
uniformly distributed throughout the range <tex>$\{a, b\}$</tex>.

*Alice*: And the next line is indeed just linear in the variable
<tex>$\phi$</tex>, where every point in the circle is equally likely
to be picked:

 :include: .mkplummer1.rb-6

*Bob*: And these values then get translated from spherical into
Cartesian coordinates in the usual way:

 :include: .mkplummer1.rb-7

*Alice*: Well, that wasn't too difficult.  I expect that choosing a velocity
may be a bit more tricky.

*Bob*: Indeed.  Aarseth <i>et al.</i> start with the observation that
the maximum velocity allowed at a radius _r_ is the escape velocity
<tex>$v_e(r)$</tex>, itself a function that depends on the radius.
The escape velocity can be determined by requiring that a particle at
radius _r_ has exactly zero total energy, <i>i.e.</i> its kinetic
energy is just enough for a parabolic escape to infinity.  Since the
potential energy for test particle moving in Plummer's model is given as

:equation:
U(r) \, = \, -\, {1\over \,\left(r^2 + 1\right)^{1/2}}

per unit mass, we can equate that to the kinetic energy, also per unit
mass, of a particle moving at the escape velocity:

:equation:
\half \left\{v_e(r)\right\}^2 \, + \, U(r) \, = \, 0 \, \Rightarrow

:equation:
\left\{v_e(r)\right\}^2  \, = \, 2\left(r^2 + 1\right)^{-1/2} \, \Rightarrow

:equation:
v_e(r)  \, = \, \sqrt{2} \left(r^2 + 1\right)^{-1/4}

This is the maximum velocity allowed at radius _r_, and we also know
that the minimum velocity at radius _r_ is zero.  The question is:
what is the probability distribution for <tex>$0\le v \le v_e$</tex>.

*Alice*: Ah, if you put it that way, the answer becomes easier: we have
to look at the distribution function for the energy of the particles:

:equation:
f(\br,\bv)d\br\bv \, = \, f(E(r,v)4\pi r^2 dr4\pi v^dv \, = \,
       {192\sqrt(2)\over7\pi}(-E)^{7/2}r^2v^2drdv

Hmm.  We now have to transform that into an equation for <tex>$v$</tex>.

*Bob*: If we compare particles with different velocities at a given point,
we know that their potential energies are all the same.  So the
probability to have an absolute value for the velocity
<tex>$v = |\bv|$</tex> at radial position <tex>$r = |\br|$</tex>
is given by

:equation:
g(v)dv \, \propto \, \left(-E(r,v)\right)^{7/2}v^2dv

Now the energy per unit mass <tex>$E(r,v) = U(r) + \half v^2$</tex>
can be written in terms of the escape velocity <tex>$v_e$</tex> as
<tex>$E(r,v) = -v_e^2 + \half v^2$</tex>.  If we introduce the
variable

:equation:
q \, = \, {v \over v_e}

we can write <tex>$E(q) \propto q^2 - 1$</tex>, for a given fixed
<tex>$r$</tex>.  The distribution function for <tex>$v$</tex> then
becomes, in terms of <tex>$q$</tex>, proportional to the following function:

:equation:
g(q) \, = \, \left(1 - q^2\right)^{7/2}q^2

*Alice*: And the range of admissable _q_ values is <tex>$0\le q \le 1$</tex>.
This looks exactly like the problem we had for determining the radial
positions.  There we knew the density, <i>i.e.</i> the probability function
to find a particle at a given position.  By integrating the density we
obtained the cumulative mass function <tex>$m(r)$</tex>, and then we
inverted that to obtain <tex>$r(m)$</tex>.

So I guess the next step is to integrate <tex>$g(q)$</tex>.  However, that
doesn't look so easy.

*Bob*: For the velocities, they choose a different approach.  If you plot
the function <tex>$g(q)$</tex>, then the height of that curve, for each
<tex>$q$</tex> value, gives you the relative probability that <tex>$q$</tex>
would lie in a region of small fixed width around that value.  You can
imagine that you can obtain a distribution of the required weighting
by throwing darts at that graph.  If you hit a point somewhere above
the graph, you throw a new dart, and you keep throwing new darts until
you hit a point below the graph, anywhere between <tex>$q=0$</tex> and
<tex>$q=1$</tex>.  If you follow that procedure, you are automatically
guaranteed that you score more hits at places where the graph is higher,
and exactly so in proportion to the height of a graph.

*Alice*: That is a clever solution.  It is called a rejection technique.
Didn't John von Neumann first apply that?  You start by allowing more
solutions than the minimal set of correct ones, and then you weed out
the incorrect ones, by rejecting them.

*Bob*: Indeed.  And to make the procedure efficient, you don't want to
throw darts way above the graph, so you limit yourself to the maximum
value that the graph attains in the interval of interest, or perhaps
a slightly higher value.  The authors of the paper choose a value of 0.1.

*Alice*: Is that a safe value?  Let's check for ourselves.  The derivative
of <tex>$g(q)$</tex> is

:eqnarray:
{dg(q)\over dq} \, &=& \, 
  2q\left(1 - q^2\right)^{7/2} -7q^3\left(1 - q^2\right)^{5/2}      \nonumber\\
&=& \, q\left(2 - 9 q^2\right)\left(1 - q^2\right)^{5/2}

To find the extrema for <tex>$g(q)$</tex>, we set the derative to zero,
and solve for <tex>$q_x$</tex>:

:equation:
q_x^2 = 2/9 \Rightarrow g(q_x) \, = \, (2/9)(7/9)^{7/2} \approx 0.092

Indeed: 0.1 is a rather tight upper limit.

*Bob*: Here is how I implemented this idea:

 :inccode: .mkplummer1.rb-8

*Alice*: I see.  So +x+ stands for <tex>$q$</tex> and +y+ stands for
<tex>$g(q)$</tex>.  You keep throwing darts until you find a +y+
value under the graph.  That gives you the corresponding +x+ value.
Since this value is equal to <tex>$q = v / v_e$</tex>, you have to
multiply +x+ with the escape velocity <tex>$v_e$</tex>, which we found
earlier to be:

:equation:
v_e(r)  \, = \, \sqrt{2}\left(r^2 + 1\right)^{-1/4}

Okay, I understand the procedure now.

*Bob*: And the procedure for picking random values for <tex>$\theta=0$</tex>
and <tex>$\phi$</tex>, and translating the velocity vector to
Cartesian coordinates, is just the same as it was in the case of the
position vector:

 :inccode: .mkplummer1.rb-9

I must admit, I'm glad you forced us to find a complete explanation
for everything.  I had basically just implemented their recipe, without
tracing the whole logic.

*Alice*: [some words of wisdom]

[MAKE SURE TO ADAPT THE DIALOGUE TO LET BOB STUMBLE ABOUT EXPLANATIONS]

== xxx

== xxx

== xxx

Write simplest <tt>mkplummer1.rb</tt>

learn to use (s)rand

check energy

check mass quartiles

subtract c.o.m. motion

cold start

== xxx


