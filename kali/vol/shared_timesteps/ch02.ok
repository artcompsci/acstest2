= Distance Measures

== Testing

*Bob*: Now that we have a shared time step code <tt>nbody_sh1.rb</tt>,
I'd like to make sure that it really gives the same results as the
previous code <tt>nbody_cst1.rb</tt> that used constant time steps.
Having good energy accuracy is one thing, but it would be much better
to check the actual particle positions.

*Alice*: How about computing the distance between the results of two runs,
in 6N-dimensional phase space?  A whole N-body system can be viewed
as a single point in a space that spans all the degrees of freedom of
the positions and velocities of all particles.

More generally, if we model a system in D dimensions, a single
particle will have D components for its position as well as its
velocity, or 2D in total.  N particles will have 2DN such degrees of
freedom.  For planar N-body systems, we need a 4N-dimensional phase
space, and for N-body systems in the real three-dimensional world we
are dealing with a 6N-dimensional phase space.

*Bob*: In practice this means, I presume, that you use Pythagoras to
compute the distance in such a large space.  In other words you take
the square root of the sum of the squares of all the differences, right?

*Alice*: Indeed.

*Bob*: So another way of looking at your suggestion is that you compute
the average distance between corresponding particles in the usual
6-dimensional phase space.  Apart from a normalization factor N, the
result would be the same.

*Alice*: Yes, that's right.  I like the more abstract picture, but your
description boils down to the same thing.

*Bob*: I find it a lot easier to think about 2D dimensions than about 2ND
dimensions.  In either case, the practical procedure is that we have to
subtract two N-body systems, point by point, and then we have to compute
the norm or `size' of the resulting system, a type of absolute value.

*Alice*: Ah, so you _do_ like abstract thinking, after all!  How about
defining a minus operator, that allows us to subtract two N-body systems,
<tt>nb1</tt> and <tt>nb2</tt>, just by writing <tt>nb1-nb2</tt>?  That
would give us a nicely compact notation.  And the 2DN-dimensional distance
between the two systems could then be given by <tt>(nb1-nb2).abs</tt>
if we define the correct absolute value operator +abs+ for the <tt>NBody</tt>
class.

*Bob*: Good idea!  However, there is no guarantee that two N-body systems
will show their particles in the output in the exact same order.  In other
words, what we need is a way to identify which particle in the one system
corresponds to which particle in the other system.

*Alice*: I guess we have to number them, by giving each body a unique
identifier.

*Bob*: Given that every object in Ruby already has an identifier called
<tt>object_id</tt>, a natural name for such an ID would be <tt>body_id</tt>.
Now that is easy to implement.  How about this:





 :inccode:acsnumber.rb

 :inccode:.nbody.rb+-

 :inccode:.nbody.rb+abs

 :inccode:.nbody.rb+abs_pos

 :inccode:acsdiff.rb

 :inccode:circular_binary.in

 :inccode:pert_circ_binary.in

 :commandoutput: acsnumber.rb < circular_binary.in > tmp0.in
 :commandoutput: acsnumber.rb < pert_circ_binary.in > tmp1.in
 :commandoutput: cat tmp0.in tmp0.in | acsdiff.rb
 :commandoutput: cat tmp0.in tmp1.in | acsdiff.rb
 :commandoutput: cat tmp0.in tmp1.in | acsdiff.rb -r -p 5
 :command: rm -f tmp0.in tmp1.in











why not more accurate for variable time step?
		    write nbodydiff

discuss how to extend it to variable time steps, then implement:
nbody_cst1.rb

nbody_sh1.rb

nbody_ind1.rb

nbody_ind2.rb

nbody_ind3.rb

world1.rb

world2.rb

world3.rb
