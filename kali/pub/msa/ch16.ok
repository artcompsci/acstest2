= Second-Order Algorithms

== Modified Euler

*Dan*: Now that we have a vector version of forward Euler, it's time
to clean up our modified Euler code as well.

*Carol*: That will be an easy translation.  I will start by copying
the old code from <tt>euler_modified_array.rb</tt> into a new file,
<tt>euler_modified_vector_try.rb</tt>.  All we have to do is to translate
the code from array notation to vector notation.  Same as what we did
with <tt>euler_vector.rb</tt>.  Here it is:

 :inccode: .euler_modified_vector_try.rb

*Erica*: What a relief!  The lines are shorter,
there are fewer lines, but what is most important: the lines are easy
to understand, with a direct correspondence between code and math.

Let's trace our history, in this regard.  We started off writing with pen and
paper:

:equation:
\br_{1} = \br + \bv dt

In our first code this became:

 :inccode: .euler_modified_1000_steps.rb-1

Then in our array code it became

 :inccode: .euler_modified_array.rb-1

and finally, in our vector code, we wrote:

 :inccode: .euler_modified_vector_try.rb-1

which is very close indeed to what we started out with:

:equation:
\br_{1} = \br + \bv dt

*Dan*: It was a lot of work, but now that we got the vector class,
I must admit that the code looks a lot more readable.  So I guess
this will make life a lot easier for us.
But before we move on, does it give the correct answers?

*Carol*: Here's the old result, from the array code:

 :commandoutput: ruby euler_modified_array.rb | tail -1

and here's what our new vector code gives:

 :commandoutput: ruby euler_modified_vector_try.rb | tail -1

*Dan*: Good!  I'm happy.

*Erica*: But I'm not, at least not completely.  Look, in the code
we are using the variable <tt>r2</tt> in two very different ways.
Early on, we use it to hold the value of <tex>$r^2$</tex>,
the square of the original variable <tex>$\br$</tex>:
<tex>$r^2 = \br\cdot\br$</tex>.  But later, toward the end
of the loop, we use the same variable to hold value of
<tex>$\br_{i+2, p}$</tex>, the predicted value of <tex>$\br_{i+2}$</tex>.

I guess Ruby doesn't mind that we assing completely different values,
even with different types, first a scalar, then a vector.  But I sure
do mind!  Someone reading this code from scratch is likely to be
confused.

*Carol*: You have a point there.  Okay, how about calling the initial
position <tex>$\br_0$</tex> instead of <tex>$\br$</tex>?  That is more
consistent anyway.  We can then use the variable name <tt>r0</tt>
instead of <tt>r</tt> for the initial vector, and the scalar value of
its square will then become <tt>r02</tt>.  So there will be no possible
confusion anymore!  Here is the new listing?




<b>[ this is how far I got ; 2007/10/20 -- Piet ]</b>

== Leapfrog

*Carol*: Erica, what kind of second-order algorithm should we use,
to replace our first-order forward Euler scheme?

*Erica*: A nice and simple scheme is the _leapfrog_ algorithm.

*Dan*: What a strange name.  Does it let particles jump around like frogs?

*Carol*: Or like children jumping over each other?

*Erica*: Something like that, I guess.  I never thought about the meaning
of the name.  It is used quite widely, although it has different names in
different fields of science.  In stellar dynamics you often hear it called
leapfrog, but in molecular dynamics it is generally called the Verlet
method, and I'm sure there must be other names in use in other fields.

Here is the idea:

:eqnarray:
\br_{i} & = & \br_{i-1} + \bv_{i-1/2} dt \label{leapfrog-leap-step1} \\
\bv_{i+1/2} & = & \bv_{i-1/2} + \ba_i dt \label{leapfrog-leap-step2}

== xxx

== xxx

Here is 

<tt>leapfrog_100.rb</tt>:

 :inccode: .leapfrog_1000_steps.rb

Try:

 :commandoutput: ruby leapfrog_1000_steps.rb > leapfrog_1000_steps.out
 :commandinput: gnuplot END
set term post eps
set output "leapfrog_1000_steps.ps"
set size ratio -1
plot "leapfrog_1000_steps.out"
quit
END

:figure: leapfrog_1000_steps.ps 10cm leapfrog_1000_steps
First attempt at leapfrog integration, with step size <tex>$dt=0.01$</tex>.

xxx
