= Completing an Orbit for the 2-Body Problem

== Choosing an Algorithm

*Carol*:
Now that we have the equations of motion for the relative position of
one particle with respect to the other, I guess we need an algorithm
to integrate these equations.

*Erica*:
Indeed, and there is a large choice!  If you pick up any book on
numerical methods, you will see that you can select from a variety of
lower-order and higher-order integrators, and for each one there are
additional choices as to the precise structure of the algorithm.

*Dan*:
What is the order of an algorithm?

*Erica*:
It signifies the rate of convergence.  Since no algorithm with a
finite time step size is perfect, they all make numerical errors.
In a fourth-order algorithm, for example, this error scales as the
fourth power of the time step -- hence the name fourth order.

*Carol*:
If that is the case, why not take a tenth order or even a twentieth
order algorithm.  By only slightly reducing the time step, we would
read machine accuracy, of order <tex>$10^{-15}$</tex> for the usual double
precision (8 byte, i.e. 64 bit) representation of floating point numbers.

*Erica*:
The drawback of using high-order integrators is two-fold: first, they
are far more complex to code; and secondly, they do not allow arbitrarily
large time steps, since their region of convergence is limited.  As a
consequence, there is an optimal order for each type of problem.  When
you want to integrate a relatively well-behaved system, such as the
motion of the planets in the solar system, a twelfth-order integrator
may well be optimal.  Since all planets follow well-separated orbits,
there will be no sudden surprises there.  But when you integrate a
star cluster, where some of the stars can come arbitrarily close to each
other, experience shows that very high order integrators lose their edge.
In practice, fourth-order integrators have been used most often for the job.

*Dan*:
How about starting with the lowest-order integrator we can think of?
A zeroth-order integrator would make no sense, since the error would
remain constant, independent of the time step size.  So the simplest
one must be a first-order integrator.

*Erica*:
Indeed.  And the simplest version of a first-order integrator is
called the <i>forward Euler</i> integrator.

*Dan*:
Was Euler so forward-looking, or is there also a <i>backward Euler</i>
algorithm?

*Erica*:
There is indeed.  In the forward version, at each time step you simply
take a step tangential to the orbit you are on.  After that, at the
next step, the new value of the acceleration forces you to slightly
change direction, and again you move for a time step <tex>$dt$</tex>
in a straight line in that direction.  Your approximate orbit is thus
constructed out of a number of straight line segments, where each one
has the proper direction at the beginning of the segment, but the
wrong one at the end.

<b>[Peter, can you make a picture here?]</b>

*Dan*:
And the <i>backward Euler</i> algorithm must have the right direction
at the end of a time step, and the wrong one at the beginning.  Let's
see.  That seems much harder to construct.  How do you know at the
beginning of a time step in what direction to move so that you come
out with the right direction tangential to a correct orbit at that
point?

<b>[Peter, can you make a picture here?]</b>

*Erica*:
You do that through iteration.  You guess a direction, and
then you correct for the mistake you find yourself making, so that
your second iteration is much more accurate, in fact first-order
accurate.  Given this extra complexity, I suggest that we start with
the forward Euler algorithm.

*Carol*:
Can't we do both, _ie_ make half the mistakes of each of the two, while
trying to strike the right balance between forward and backward Euler?

*Erica*:
Aha!  That is a good way to construct better algorithms, which then
become second-order accurate, because you have canceled the first-order
errors.  Examples are second-order Runge Kutta, and leapfrog.  We'll
soon come to that, but for now let's keep it simple, and stay with
first order.  Here is the mathematical notation:

:eqnarray:
\label{ForwardEulerStep}
\br_{i+1} & = & \br_i + \bv_i dt    \nonumber \\
\bv_{i+1} & = & \bv_i + \ba_i dt

for the position <tex>$\br$</tex> and velocity <tex>$\bv$</tex> of an individual particle,
where the index <tex>$i$</tex> indicates the values for time <tex>$t_i$</tex> and <tex>$i+1$</tex> for
the time <tex>$t_{i+1}$</tex> after one more time step has been taken:
<tex>$dt = t_{i+1} - t_i$</tex>.  The acceleration induced on a particle by the
gravitational forces of all other particles is indicated by <tex>$\ba$</tex>.
So, all we have to do now is to code it up.  By the way, let's rename
the file.  Rather than a generic name <tt>nbody.rb</tt>, let's call it
<tt>euler.rb</tt>.

*Dan*:
Erica, go for it!

== Specifying Initial Conditions

*Carol*: In order to solve a differential equation, you have to provide
initial conditions.

*Erica*: 
You mean we have to start by specifying the initial separation between
the particles.  How about a simple choice like this?

 :inccode: .euler_elliptic.rb-1

*Dan*: Let me put this into words.  The relative position vector is
chosen along the <tex>$x$</tex> axis at a distance of unity from the
origin where the other particle resides in the relative coordinate
system that we use: <tex>$\br = \{1, 0, 0\}$</tex>.  The relative
velocity is chosen to be <tex>$0.5$</tex> in the direction of the
positive <tex>$y$</tex> axis: <tex>$\bv = \{0, 0.5, 0\}$</tex>.
This means that the initial motion is at right angles to initial separation.

*Carol*: Does this mean that the two particles will move around each other
in a circle?

*Erica*: Probably not, unless we give exactly the right velocity
<tex>$v_c$</tex> needed for circular motion.  In general, the orbit
will take the shape of an ellipse, if the two particles are bound.
If the initial speed is too high, the particles escape from each
other, in a parabolic or hyperbolic orbit.

*Carol*: What is the value of <tex>$v_c$</tex>?

*Erica*: We can look it up in any text book on celestial mechanics,
but I remember a quick way to derive the expression.  According to
the virial theory, for a circular orbit, the kinetic energy
<tex>$E_{kin}$</tex> is just one half of the potential energy
<tex>$E_{pot}$</tex>, and opposite in sign.  This makes the magnitude
of the total energy <tex>$E_{tot}$</tex> equal to that of the kinetic
energy:

:equation:
E_{tot} = E_{kin} + E_{pot} = E_{kin} - 2 E_{kin} = - E_{kin}

We have already derived

:equation:
E_{kin} = {1 \over 2}\ {M_1 M_2 \over M_1 + M_2} v^2

and

:equation:
E_{pot} = -\ {M_1 M_2 \over r}

So when we insist that <tex>$E_{pot} = -2 E_{kin}$</tex>, we get for the
circular velocity

:equation:
v_c^2 = {M_1 + M_2 \over r}

In our case, we have chosen <tex>$M_1 + M_2$</tex> to be unity, which
means:

:equation:
v_c = {1 \over \sqrt r}

*Dan*: So with your choice of an initial separation of <tex>$r=1$</tex>,
we have <tex>$v_c = 1$</tex>.  Ah, you want to start the particles off
with a velocity that is only half as large, which means that the two
particles will start falling towards each other, because they don't
have enough relative speed to keep them in a circular orbit?

*Erica*: Yes, I guess that is what will happen.  I just typed in some
simple numbers.

*Carol*: Wouldn't it be better to start with the simplest case, that of a
circular orbit, to test whether at least we can get that right?  There we
know exactly what should happen, whereas with an elliptic orbit, it will
be harder to see whether the ellipse has the exact right shape.

*Erica*: You have a point there.  Okay, lets do that.  Here is the starting
point for a circular orbit:

 :inccode: .euler_circular_step.rb-1

*Dan*: And from this point on we have to step forward in time.
I have no idea how large the time step +dt+ should be.  Certainly
it should be very small compared to the time it will take for our two
bodies to move around a circle.

*Carol*: In other words, the distance +dr+ over which the particles travel
during a time step +dt+ much be very small compared to the separation
between the two particles:

:equation:
dr = v\ dt \ll r

With <tex>$v=1$</tex> and <tex>$r=1$</tex>, this means
<tex>$dt\ll 1$</tex>.

We could take `much less than 1' to mean 0.1, for starters:

 :inccode: .euler_circular_step.rb-2

== Taking the First Step

*Erica*: Now we are ready to let the particles move to their next position,
from our starting point of time <tex>$t=0$</tex> to <tex>$t=0.1$</tex>,
by solving the differential equation for the Newtonian two-body problem,
Eq. (ref(Newton2bodysimple)).

*Carol*: And we do so by using the forward Euler approximation
(ref(ForwardEulerStep)).  How about coding up that equation first?

*Erica*: That would be:

 :inccode: .euler_circular_step.rb-3

*Dan*: But we haven't calculated the acceleration +a+ yet.

*Carol*: This is an important example of code writing, something called
`wishful thinking' or `wishful programming'.  You start writing a code
as if you already have the main ingredients in hand, and then you go
back and fill in the commands needed to compute those ingredients.

*Dan*: That sounds like a top-down programming approach, which makes sense:
I like to start with an overview of what needs to be done.  It is all too
easy to start from the bottom up, only to get lost while trying to put all
the pieces together.

*Erica*: To compute the acceleration, let me copy Eq. (ref(Newton2bodysimple))
here:

:equation:
\ba = - \frac{\br}{r^3}

*Dan*: Can you write it out in component notation?

*Erica*: If I write <tex>$\ba=\{a_x,a_y,a_z\}$</tex> for the relative
acceleration vector between the two and particles and
<tex>$\br=\{x,y,z\}$</tex> for their separation vector, we get:

:eqnarray:
a_x &=& - \frac{x}{r^3}    \nonumber \\
a_y &=& - \frac{y}{r^3}    \nonumber \\
a_z &=& - \frac{z}{r^3}

where the magnitude of the separation <tex>$r$</tex> is defined as

:equation:
r = \sqrt{x^2 + y^2 + z^2}

Let me start with the last line:

 :inccode: .euler_circular_step.rb-4

*Carol*: Let's see whether I remember my vector analysis class.  The quantity
<tex>$\br$</tex> is called a vector, and the quantity <tex>$r$</tex> is called
a scalar, right?

*Erica*: Indeed.  The last quantity is a scalar because it is independent of
your choice of coordinate system.  If we rotate out coordinates, the values
of <tex>$x$</tex> and of <tex>$y$</tex> and of <tex>$z$</tex> may all change,
and therefore <tex>$\br$</tex> will change.  However, <tex>$r$</tex> will
stay the same, and that is a good thing: it denotes the physical distance
between the particles, something that you can measure.  When two people use
two different coordinate systems, and both measure <tex>$r$</tex>, the value
they find had better be the same.

*Dan*: My Ruby book tells me that you must add the line

 :inccode: .euler_circular_step.rb-5

in order to use the square root method +sqrt+, where the term method
is used in the same way the word function is used in C and the word
subroutine is used in Fortran.  The <tt>include</tt> statement is
needed in order to gain access to the +Math+ module in Ruby, where
many of the mathematical methods reside.

*Erica*: Thanks!  Now the rest is straightforward:

 :inccode: .euler_circular_step.rb-6

== Printing the Result

*Dan*: Shall we see whether the program works, so far?  Let's run it!

*Carol*: Small point, but . . . perhaps we should add a print statement,
to get the result on the screen?

*Erica*: I guess that doesn't hurt!  The Ruby syntax for printing seems to be
very intuitive, following what they call the `principle of least surprise':

 :inccode: .euler_circular_step.rb-7

*Carol*: I like that principle!  And indeed, this couldn't be simpler!

*Dan*: Apart from this mysterious <tt>\n</tt> at the end.  What does that do?

*Carol*: It prints a new line.  This notation is borrowed from the C language.

*Erica*: So here it is, our first program, <tt>euler.rb</tt>, which is supposed
to take one step in time:

 :inccode: .euler_circular_step.rb

As you can see, I decided to print the positions and velocities twice,
just before and just after taking one integration step.  Well, let's
see what happens:

 :command: cp euler_circular_step.rb euler.rb
 :commandoutput: ruby euler.rb

== Verification & Validation

*Dan*: That all looks very reasonable.  In fact, we can even check everything
by hand.  Since we have initially

:equation:
\br(0) = \{x, y, z\} = \{1,0,0\}

and

:equation:
\bv(0) = \{v_x, v_y, v_z\} = \{0,1,0\}

the new position must be:

:equation:
\br(dt) = \br + \bv dt = \{1,dt,0\}

*Carol*: And this is indeed what we see in the first half of the last output
line.

*Dan*: To compute the new velocity, we have to first compute the
acceleration vector.  Let's see, Newton's equation of motion for the
two-body problem, as written above in component form, gives simply:

:equation:
\ba = \{a_x, a_y, a_z\} = \{-1,0,0\}

This means that

:equation:
\bv(dt) = \bv + \ba dt = \{-dt,1,0\}

*Erica*: And this is indeed what is printed in the last half of the last
output line.

*Dan*: Perfect!

*Carol*: Well, sort-of.  We have verified that our program does what the
algorithm intended, and that is certainly nice!  But this is only half
of the work.  We now have to check whether this particular algorithm
does indeed give a reasonable result, which corresponds to the behavior
of gravitating particles in the real world.  This is called validation.
In the computer science literature these two checks are often called 
V&V, for Verification and Validation.

In other words, we have passed the verification test, so now we have
to do a validation test.  For example, we can ask whether this first
step keeps the two particles on a circular orbit.  After the first
step, the new separation is:

:equation:
r(0.1) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.1^2} = \sqrt{1.01} \approx 1.005

*Dan*: Instead of the correct value of <tex>$r(0.1)=1$</tex>, we are half a
percent off.  Not bad, I would say.

*Carol*: Not bad for one step, perhaps, but our orbit has a radius of unity,
which means a circumference of <tex>$2\pi \approx 6.3$</tex>.  With a velocity
of unity, it will take <tex>$63$</tex> steps to go around the circle,
at the rate we are going.  And if every step introduces `only' half a percent
error, and if the errors built up linearly, we wind up with a total error of
more than 30%, even during the first revolution!

*Dan*: Good point.  Of course, we don't know whether the errors build up
linearly, but for lack of a better idea, that would be the first guess.
Perhaps we should take a smaller time step.  What would happen if we would
use <tex>$dt = 0.01$</tex>?  Let's repeat your analysis.  After one step,
we would have

:equation:
r(0.01) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.01^2} = \sqrt{1.0001}
\approx 1.00005

We now need roughly <tex>$630$</tex> steps to go around the circle,
If the errors build up linearly, the radial separation will grow to
something like <tex>$1 + 630*0.00005 \approx 1.03$</tex>.  Aha!  Only
a 3% error, instead of roughly 30%.

*Erica*: Bravo!  You have just proved that the forward Euler scheme is
a first-order scheme!  Remember our discussion at the start?  For a
first-order scheme, the errors scales like the first power of the time
step.  You just showed that taking a time step that is ten times smaller
leads to a ten times smaller error after completing one revolution.

*Dan*: Great!  I thought that numerical analysis was a lot harder.

*Carol*: Believe me, it _is_ a lot harder for any numerical integration
scheme that is more complex than first-order.  You'll see!

*Dan*: I can wait.  For now I'm happy to work with a scheme which I can
completely understand.  On to the next step!  And ah, yes, let us take
steps with a size <tex>$dt = 0.01$</tex>, given what we've just learned.

== A Simple Loop

*Erica*: We'd better introduce a loop, since we'll need to take a lot of
steps.  At the very least we want to move around the circle once, which
would take a bit more than six time units.  Let's make it ten time units,
for good measure.  With a step size of <tex>$dt = 0.01$</tex>, we'll have
to take <tex>$1000$</tex> steps to reach <tex>$t = 10$</tex>.

*Carol*: Let's have a look at the Ruby book.  How do you repeat the same
thing +k+ times?  Ah, here it is.  That looks funny!  You write
<tt>k.times</tt>!  So to traverse a piece of code <tex>$1000$</tex> times,
you enclose that piece of code within the following loop wrapper:

 :inccode: .euler_circular_bug.rb-1

*Dan*: Surely you are joking!  That is carrying the principle of least
surprise a bit too far to believe.  How can that work?  Can a computer
language really stay so close to English?

*Carol*: The key seems to be that Ruby is an object-oriented language.
Each `thing' is ruby is an object, which can have attributes such as
perhaps internal data or internal methods, which may or may not be
visible from the outside.

*Erica*: I have heard the term `object-oriented programming.'  I really
should browse through the Ruby book, to get a bit more familiar with that
approach.

*Dan*: We all should.  But for now, Carol, how does your key work?
Is the number <tex>$1000$</tex> also an object?

*Carol*: You guessed it!  And every number has by default various methods
associated with it.  One method happens to be called +times+.

*Erica*: And what +times+ does is repeat the contant of its argument,
whatever is within the curly brackets, +k+ times, if the number is +k+.

*Carol*: Precisely.

*Dan*: Amazing.  Well, I would be even more amazed to see this work.

*Erica*: Why shouldn't it work?  Let's try it!  Telling the computer how
to take the first step was hard, but letting it take another 999 steps
should be easy, given this natural looping construct.  Here is the new
version of the code:

 :inccode: .euler_circular_bug.rb

== A Surprise

*Carol*: I don't think you would like to read through 1001 lines of output.
Let's run the code while redirecting the output to a file <tt>euler.our</tt>.

 :command: cp euler_circular_bug.rb euler.rb
 :commandoutput: ruby euler.rb > euler.out

We can then have a peek at, say, the first five lines and the last
five lines, while skipping the 991 lines in between:

 :commandoutput: head -5 euler.out
 :commandoutput: tail -5 euler.out

*Dan*: Instead of a bunch of numbers, I'd rather see a plot of the orbit.

*Erica*: I agree, we should do that soon.  But hey, the numbers do tell us
something already, namely that there is something seriously wrong!

*Carol*: Right you are, the numbers are much too large.  We are trying
to let two particles move around a circle, at a relative distance of 1.
However, here the separation in the <tex>$y$</tex> direction alone is
already larger than <tex>$11$</tex>, so the total separation must be
even larger.  I did not expect such a large error.

*Dan*: Hmmm, yes, that is rather surprising.  And yet, look, the result
of the very first step is exactly correct.  It is just what we would
expect, when scaling our earlier result, from a time step of
<tex>$dt=0.1$</tex> to a time step of <tex>$dt=0.01$</tex>.

*Erica*: Well, let us look at the orbit.  How do we make a plot?

*Carol*: I suggest using <tt>gnuplot</tt>, present on any Linux
running system, and something that can be easily installed on many
other systems as well.  The style is not particularly pretty, but at
least it will give us something to look at.

*Dan*: How do you invoke <tt>gnuplot</tt>?

*Carol*: To use it is quite simple, with only one command
needed to plot a graph.  In our case, however, I'll start with the
command <tt>set size ratio -1</tt>.  A positive value for the size
ratio scales the aspect ratio of the vertical and horizontal edge of
the box in which a figure appears.  But in our case we want to
set the scales so that the unit has the same length on both the x and
y axes.  Gnuplot can be instructed to do so by specifying the ratio to
be <tt>-1</tt>.  In fact, let me write the line <tt>set size ratio
-1</tt> in a file called <tt>.gnuplot</tt> in my home directory.  That
way we don't have to type it each time we use gnuplot.  Okay, done.
Now let's have our picture:

xxxxxxxxx

Let's plot it (fig REF(euler_circular_bug) ):  [upper case REF to
avoid the current bug]

 gnuplot
 set size ratio -1
 plot "euler.out"
 quit

 :commandinput: gnuplot END
set term post eps
set output "euler_circular_bug.ps"
set size ratio -1
plot "euler.out"
quit
END

 :figure: euler_circular_bug.ps 10cm euler_circular_bug
 First attempt at integrating the two-body problem: failure.

== Debugging

xxxxx

== Much Better

Corrected code <tt>euler_circular.rb</tt>, but we show it as if it is called
<tt>euler.rb</tt>:

 :inccode: .euler_circular.rb

Let's run it:

 :command: cp euler_circular.rb euler.rb
 :commandoutput: ruby euler.rb > euler.out
 :commandoutput: head -5 euler.out
 :commandoutput: tail -5 euler.out

Let's plot it:

 :commandinput: gnuplot END
set term post eps
set output "euler_circular.ps"
set size ratio -1
plot "euler.out"
quit
END

 :figure: euler_circular.ps 10cm euler_circular
 Second attempt at integrating the two-body problem: looking a lot better.

