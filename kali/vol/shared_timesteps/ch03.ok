= A Puzzle

== Yoshida

*Bob*: We can now put our distance measurement tool to good use, by
testing whether our shared time step integrator really does the right
thing.
We'll do a test run with the constant time step code first,
and then compare the results with that from the shared time step
code.

*Alice*: Let's take a fancy integrator.  How about Yoshida's sixth order
scheme?

*Bob*: As you wish.  And while we're at it, let's check whether the scheme
is still sixth order, in constant as well as shared time step form.  First
I'll prepare initial conditions with the particles all properly numbered:

 :commandoutput: ruby mkplummer.rb -n 4 -s 1 | ruby nbody_set_id.rb > test.in

Starting with the constant time step version, let's choose the
<tt>yo6</tt> integrator, but what options did we use for algorithm
choice?  I always forget what names we gave our options.  Let's ask
our clop function to provide them:

 :commandoutput: ruby nbody_cst1.rb -h

== Energy Scaling

Aha, now I remember.  Okay, how about this?

 :commandoutput: ruby nbody_cst1.rb -g yo6 -t 1 < test.in > yo6cst.out

Now let's make the time step twice as small:

 :commandoutput: ruby nbody_cst1.rb -g yo6 -t 1 -c 0.005 < test.in > yo6cst_half.out

== Phase Space Distance Scaling

*Alice*: Indeed, sixth order!  Very close to a factor <tex>$2^6=64$</tex>
difference.  But before we go further, and use our shared time step
integrator, let's first see whether in this case the distance
in phase space also scales like the sixth power in the time step.

*Bob*: Ah, yes, good idea.  But in order to do so, we have to know what the
`true' solution is.  When we check energy conservation, we know that a
truly accurate integration would give us an energy error of zero, but when
we compare the two outputs we just got, we need to compare them to an even
more accurate soluation.  Well, we can run our code with a much smaller
time step, and declare that the result should be close to `true':

 :commandoutput: ruby nbody_cst1.rb -g yo6 -t 1 -c 0.001 < test.in > yo6cst_tenth.out

First we'll compare the first run with the `true' run:

 :commandoutput: cat yo6cst.out yo6cst_tenth.out | ruby nbody_diff.rb

And second we'll take the second run, to compare it with the `true' one:

 :commandoutput: cat yo6cst_half.out yo6cst_tenth.out | ruby nbody_diff.rb

*Alice*: Wow, very nice indeed!  Almost exactly a factor 64 smaller.

== The Shared Time Step Code

*Bob*: After all these preliminaries, we can finally test our shared time
step code:

 :commandoutput: ruby nbody_sh1.rb -g yo6 -t 1 < test.in > yo6sh.out

That's quite accurate!  This means that, if all is well, the distance between
this output and that of the previous `true' output should be a lot smaller
than the distance between the more accurate run with constant time
steps and the `true' output.  Let's check:

 :commandoutput: cat yo6sh.out yo6cst_tenth.out | ruby nbody_diff.rb

*Alice*: What is that?!?

*Bob*: That sure doesn't look good.  How can the distance be so large?

== Back to Basics

*Alice*: Could it be that Yoshida's integrator is just too fancy for our
purpose?  Perhaps that was not such a good choice to start our testing
with.  Let's go back to basics, and do the same thing with the leapfrog
integrator instead:

 :commandoutput: ruby nbody_sh1.rb -g leapfrog -t 1 < test.in > leap_sh.out
 :commandoutput: ruby nbody_sh1.rb -g leapfrog -t 1 -c 0.001 < test.in > leap_sh_tenth.out

*Bob*: The energy scales like it should for a second-order integrator:
a hundred times better accuracy for a ten times smaller time step.

*Alice*: And, really, the phase space distance should also become a
hundred times better.  I hope it does:

 :commandoutput: cat leap_sh.out yo6cst_tenth.out | ruby nbody_diff.rb
 :commandoutput: cat leap_sh_tenth.out yo6cst_tenth.out | ruby nbody_diff.rb

== Even more Basic

*Bob*: Well, it doesn't.  What is going on here?

*Alice*: Let's completely forget about sixth-order integrators, and
stick to the basics completely.  If we do a third leapfrog integration,
we can use the result of that run as our yard stick:

 :commandoutput: ruby nbody_sh1.rb -g leapfrog -t 1 -c 0.0001 < test.in > leap_sh_hundredth.out
 :commandoutput: cat leap_sh.out leap_sh_hundredth.out | ruby nbody_diff.rb
 :commandoutput: cat leap_sh_tenth.out leap_sh_hundredth.out | ruby nbody_diff.rb

*Bob*: That doesn't make much difference.  Still no quadratic behavior.

*Alice*: No matter what we do, we get linear behavior, instead of quadratic.

*Bob*: That should tell us something.  But what?

*Alice*: Beats me.

*Bob*: This is ennoying.  Just when we were having fun!

*Alice*: How about a cup of tea first?

*Bob*: Feel free to get some tea, but I'll stay here.  I just can't stand
this.  What could be going so terribly wrong here?
