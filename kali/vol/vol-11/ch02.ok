= Sprinkling Particles in Space

== A Classic Recipe

*Alice*: Did you start building a star cluster, using Plummer's model as a
blueprint?

*Bob*: Yes, here is a quick and dirty version that I cobbled together.
It was a lot easier than I expected, since I stumbled upon a nice
recipe, which must be a classic in stellar dynamics.  I follewed it
line by line, in my implementation.  It was published in the paper
<i>A comparison of Numerical Methods for the Study of Star Cluster
Dynamics</i>, by Sverre Aarseth, Michel Henon, and Roland Wielen,
which appeared ages ago, in 1974, in Astron. Astroph.  <b>37</b>, 183.

*Alice*: I remember reading that paper as a student.

*Bob*: You are _that_ ancient?

*Alice*: Not quite.  I must have just started high school at that time.
I mean that I read it as an undergraduate when I wanted to do a small
N-body project for my final thesis.  My advisor recommended it.  And
indeed, it was an influential paper by some of the masters in the
field, around that time.

I remember it well: the paper made the first detailed quantitative comparison
between the Monte-Carlo Fokker-Plank method and direct N-body integration.
They even showed the results for runs with a few hundred particles.
Hard to believe that they got so much compute done, given the slow speed
of computers at that time.

*Bob*: That is impressive, given that computers have increased their speed
by a factor ten every five years or so.  That means that in 2004 computers
are a million times faster than what they had available.  I bet that my
camera is a lot more powerful than the computers in their university centers.

*Alice*: And I'm sure your camera has way more storage as well.  But
what was actually most impressive was how much information they were
able to squeeze out of their calculations, given their limited
resources.  Anyway, why did you bring up this paper?

*Bob*: Because it contains a nifty recipe for constructing a Plummer's model.

*Alice*: Hey, I didn't remember that.  Really?

*Bob*: They wrote it as an appendix.  Everything was done analytically, except
for the fact that they used a rejection technique at the last step, to
get the velocities.

*Alice*: I must not have looked at the appendix.  Well, that is convenient.
Can you show me your code?

*Bob*: Here it is, and I warned you, I haven't commented it or cleaned it up:
I just translated their recipe straight from the appendix into Ruby.

== A first Stab

 :inccode: .mkplummer1.rb-toriaezu

== Choosing a Distance

*Alice*: Can you tell me what their recipe was, and how you implemented it?

*Bob*: My pleasure.  The start by sprinkling particles in space, as a random
realization of the mass density distribution of Plummer's model.  They then
give each particle a velocity with a random direction and a magnitude that
is also random, but drawn from the appropriate velocity distribution at that
point in space.

*Alice*: The first step must be the simplest, since we already know the
density distribution <tex>$\rho(r)$</tex>, which you derived from the
potential.  How exactly do they use the density for particle sprinkling?

*Bob*: They describe their technique in a few words, and I had to read
those words carefully, and do some head scratching, to figure out what
it meant.  But as always, once you see it, it is really easy.  Let me
try to summarize it in my own words.

First we introduce the cumulative mass distribution

:equation:
\label{mrsymb}
m(r) \, = \, \int_0^r 4 \pi r^2 \rho(r) dr

which is the amount of mass that is included within the star cluster
inside a distance <tex>$r$</tex> from the center.  When we create a
new star, and place it at radius <tex>$r$</tex>, that star will have
<tex>$m(r)$</tex> of the mass of the cluster at positions closer to
the center, and <tex>$M-m(r)$</tex> of the mass at positions further
from the center.

In other words, it will see a fraction <tex>$m(r)/M$</tex> of the
total mass inside its radial position.  Now that fraction could be
anything between 0 and 1.  It will be 0 if the particle is placed
exactly in the center, and it will approach 1 if the particle is
placed very far away, reaching 1 when the particle is placed at
infinity.

The ranking of each particle, in terms of the enclosed mass, is random
and uniform in the mass fraction.  In other words, <tex>$m(r)/M$</tex>
will be a random value between 0 and 1, with each value equally likely.

So here is the idea: spin a random number generator in order to obtain
a a random number <tex>$m_i$</tex>, with <tex>$0 \le m_i \le M$</tex>,
and we consider that to be the fractional mass contained within the
radius <tex>$r_i$</tex> of particle <tex>$i$</tex>.  So all we know is
that <tex>$m(r_i)=m_i$</tex>, but what we need to know is
<tex>$r_i$</tex> itself.  So the procedure is to invert (ref(mrsymb))
to obtain a function <tex>$r(m)$</tex>, and then life is simple:
<tex>$r_i=r(m_i)$</tex>.

*Alice*: That sounds straightforward.  Can you show me the expressions
you found for <tex>$m(r)$</tex> and <tex>$r(m)$</tex>?

*Bob*: I simply took their expressions.  They use a system of units in which
the total mass _M_, the gravitational constant _G_ and the structural length
scale _a_ that we used above are all unity.  The mass enclosed within
a radius _r_ then becomes:

:equation:
\label{mr-ahw}
m(r) \, = \, r^3\left(r^2 + 1\right)^{-3/2}

and the radius that corresponds to a mass fraction becomes:

:equation:
\label{rm-ahw}
r(m) \, = \, \left(m^{-2/3}-1\right)^{-1/2}

As you can see in the second line of the inner loop in my +mkplummer+
method, this is how I determine the radial position of each particle,
using Ruby's random number generator +rand+:

 :include: .mkplummer1.rb-4

*Alice*: Hmm.  You didn't check whether they had done their math
correctly?

*Bob*: No need to.  This is a paper by Aarseth, Henon, Wielen.
Besides, it is thirty years old and has been cited zillions of times
by others.  I'm sure this is a result that can be trusted.

*Alice*: I don't like to accept things on trust, no matter what the
authority may be behind it.  Not that I expect them to be wrong,
I agree that that would be highly improbable.  Still, I would feel
much better to derive the results ourselves.  Besides, if we work
it out now, we can both use those notes when we have to teach it in
class to the student.  Better still, we just put it into the material
we preper for them on the web.

*Bob*: Okay, if you like.  Your turn, though, I already derived the
density.  Do you want to use a package from symbolic integration?
Differentation is easy enough by hand, but I must admit, I'm a bit
rusty in my integration.

== Cumulative Mass
 
*Alice*: So am I, and that is exactly a reason to do it with pen and
paper, tempting as it is to use a symbolic package.  Okay.  I'll start
with the density you derived:

:equation:
\rho(r) \, = \, {M \over 4\pi } {3a^2 \over \,\left(r^2 + a^2\right)^{5/2}}

By definition, this gives us for the cumulative mass, as a function of radius:

:eqnarray:
m(r) \, &=& \, \int_0^r 4 \pi r^2 \rho(r) dr                       \nonumber\\
  &=& \, 
\int_0^r {3M\over a^3}r^2\left(1+{r^2\over a^2}\right)^{-5/2}dr

The variable <tex>$x$</tex> appears in the integrand only in terms of
the combination <tex>$x^2/a^2$</tex>, so a natural change of variables is:

<tex>$$
x = {r^2\over a^2} \,\,\,\,\,\, \Rightarrow\,\,\,\,\,\, 
r = a\sqrt{x} \,\,\,\,\,\, \Rightarrow \,\,\,\,\,\, 
dr = {a\over2}\,{dx\over\sqrt{x}} \,\,\,\,\,\, \Rightarrow 
$$</tex>

which gives us:

:eqnarray:
m(r) \, &=& \, {3M\over a^3}
\int_0^{r^2/a^2} (a^2x)(1+x)^{-5/2}{a\over2}\,{dx\over\sqrt{x}}     \nonumber\\
&=& \, {3M\over 2}
\int_0^{r^2/a^2} x^{1/2}(1+x)^{-5/2}dx                              \nonumber

It is easier to bring the total mass to the other side, as an expression
for the fractional cumulative mass.  I don't like the high power
$</tex>5/2$</tex> in the integrand.  I'll use integration by parts to
lower the power:

:eqnarray:
{m(r)\over M} \, &=& \, 
-\int_0^{r^2/a^2} x^{1/2}{d\over dx}\left\{(1+x)^{-3/2}\right\}dx  \nonumber\\
\, &=& \, -\int_0^{r^2/a^2} d\left\{x^{1/2}(1+x)^{-3/2}\right\}
\,\,+\half\int_0^{r^2/a^2}(1+x)^{-3/2}
{d\over dx}\left\{x^{1/2}\right\}dx                             \nonumber\\
&=& \, -\left. x^{1/2}(1+x)^{-3/2}\right|_0^{r^2/a^2}
\quad\quad\quad+\half\int_0^{r^2/a^2} x^{-1/2}(1+x)^{-3/2}dx         \nonumber

That looks a bit better already.  How about another change of variables:

<tex>$$
y = {1\over x} \,\,\,\,\,\, \Rightarrow\,\,\,\,\,\, 
x = {1\over y} \,\,\,\,\,\, \Rightarrow \,\,\,\,\,\,
dx = -{1\over y^2}\,dy \,\,\,\,\,\, \Rightarrow 
$$</tex>

This gives us:

:eqnarray:
{m(r)\over M} \, &=& \, 
-{r \over a}\left(1+{r^2\over a^2}\right)^{-3/2}\quad\quad\quad\,\,\,
+\half\int_\infty^{a^2/r^2} y^{1/2}\left(1+{1\over y}\right)^{-3/2}
\left\{-{1\over y^2}\,dy\right\}                                   \nonumber\\
 &=& \, 
-{r \over a}\left(1+{r^2\over a^2}\right)^{-3/2}\quad\quad\quad\,\,\,
-\half\int_\infty^{a^2/r^2} y^{-3/2}\left(1+{1\over y}\right)^{-3/2}dy   \nonumber\\
 &=& \, 
-{r \over a}\left({r^2\over a^2}\left({a^2\over r^2}
+1\right)\right)^{-3/2}\,\,\,
-\half\int_\infty^{a^2/r^2} (y+1)^{-3/2}dy   \nonumber\\
 &=& \, 
-{r \over a}\,\left({r \over a}\right)^{-3}
\left({a^2\over r^2}+1\right)^{-3/2}\,
+\left. (y+1)^{-1/2}\right|_\infty^{a^2/r^2}   \nonumber\\
 &=& \, 
-{a^2 \over r^2}\left(1+{a^2\over r^2}\right)^{-3/2}\quad\quad\quad
+\left(1+{a^2\over r^2}\right)^{-1/2}            \nonumber\\
 &=& \, \quad\quad\,\,
\left(1+{a^2\over r^2}\right)^{-3/2}\left\{-{a^2 \over r^2}
+\left(1+{a^2\over r^2}\right)\right\}                    \nonumber\\
 &=& \, \quad\quad\,\,
\left(1+{a^2\over r^2}\right)^{-3/2}

So here is what we were looking for:

:equation:
m(r) \, = \, M\left(1+{a^2\over r^2}\right)^{-3/2}

Indeed eq. (ref(mr-ahw)), with their choice of units.

*Bob*: Well, if you are rusty in your integrations, then I don't know what
to call myself.  Nice job!  It is always surprising to me how the result
of that type of calculation can come out in such a simple form.

*Alice*: There probably is a good physical reason for it to be this simple.
Let's think.  I started with density, something that you had found by
differentiation, and then I integrated the product of the density and
the geometric opening angle factor of <tex>$4\pi r^2$</tex>.  Apart from
that factor, integration and differentiation would have cancelled.  Pity.

*Bob*: Hey, wait a minute.  I found the density by integrating alright, but
in the following way, using Poisson's equation:

:equation:
{1\over r^2}{d\over dr}\left( r^2{d\over dr}\Phi(r)\right) \,=\, 4\pi G\rho(r)

Doesn't that have exactly the factor <tex>$r^2$</tex> you were looking for?

*Alice*: It does . . .  Hey, I could have started there!  I could have written:

:eqnarray:
m(r) \, &=& \, \int_0^r 4 \pi r^2 \rho(r) dr                       \nonumber\\
  &=& \, 
{1\over G}\,
\int_0^r {d\over dr}\left( r^2{d\over dr}\Phi(r)\right)            \nonumber\\
  &=& \, 
{1\over G}\,
\left. {d\over dr}\left( r^2{d\over dr}\Phi(r)\right)\right|_0^r    \nonumber\\
  &=& \, 
{1\over G}\, r^2{d\Phi \over dr}                                    \nonumber

*Bob*: Ah, I remember telling you that it might come in handy to have the
derivatives of the potential at hand.

*Alice*: Not only that, here is the physical meaning we were looking for!
You also mentioned that the gradient of the potential is the gravitational
force, apart from a minus sign.  So what this equation is telling us, is
simply that the physical force is proportional to mass and inverse
proportional to the radius squared: Newton's gravity!  We could have
started that way.  The force on a particle with mass <tex>$\mu$</tex> at
distance <tex>$r$</tex> from the center is of course:

<tex>$$
F \, = \, G \, {m(r) \over r^2}
$$</tex>

and also equal to:

<tex>$$
F \, = \, -\, {d\Phi \over dr}
$$</tex>

*Bob*: You're right.  If we would have started with those two lines, we
could have written

<tex>$$
m(r) \, = \, {1\over G}\, r^2{d\Phi \over dr}
$$</tex>

right away.  And with the expression I wrote down yesterday,

<tex>$$
\frac{d}{dr}\Phi(r) \,= \, GM {r \over \,\left(r^2 + a^2\right)^{3/2}}
$$</tex>

this would have given us:

:eqnarray:
m(r) \, &=& \, {1\over G}\, r^2{d\Phi \over dr}                    \nonumber\\
&=& \, {r^3 \over \,\left(r^2 + a^2\right)^{3/2}}                  \nonumber

*Alice*: Quite a bit faster than my juggling of integrals!  We could have
used a healthy dose of physical intuition, before embarking on that lengthy
computation.

*Bob*: xxx

== xx

<tex>$$
m(r) \, = \, r^3\left(r^2 + 1\right)^{-3/2} \, \Rightarrow \,
$$</tex>

<tex>$$
\left\{m(r)\right\}^{-2/3} \, = \, r^{-2}\left(r^2 + 1\right) \, \Rightarrow \,
$$</tex>

<tex>$$
r^2\left\{m(r)\right\}^{-2/3} \, = \, \left(r^2 + 1\right) \, \Rightarrow \,
$$</tex>

<tex>$$
r^2\left(\left\{m(r)\right\}^{-2/3}-1\right) \, = \, 1  \, \Rightarrow \,
$$</tex>

<tex>$$
r(m) \, = \, \left(m^{-2/3}-1\right)^{-1/2}
$$</tex>

*Bob*: this is indeed how I determined the radius, in the following line:

 :include: .mkplummer1.rb-4

Here a call to +rand+ gives us a random floating point number between 0 and 1,
which is just want we want for our mass shell, that contains a random amount
of matter, between 0 (in the center) and 1 (at infinity), given that we have
normalized the total amount of mass in our model to <tex>$M=1$</tex>.

*Alice*: So now that you have chosen the radial position of your particle,
you can assign random values to the usual spherical coordinates
<tex>$\theta$</tex> and <tex>$\phi$</tex>.  The latter is easy, since any
azimuthal angle <tex>$\phi$</tex> is equally likely, by spherical symmetry.
To pick a random value for <tex>$\theta$</tex>, however, we have to make
sure that the spherical integration element <tex>$\sin\theta d\theta$</tex>
gets an equal weight for any <tex>$\theta$</tex> value.  In other words,
any value for <tex>$d\left(\cos\theta\right)$</tex> is equally likely.

*Bob*: Yes, and the highest and lowest values occur for <tex>$\theta=0$</tex>,
along the positive _z_ axis, and for <tex>$\theta=\pi$</tex>, along
the negative _z_ axis.  <tex>$\cos\theta$</tex> thus runs from <tex>$+1$</tex>
to <tex>$-1$</tex>.  All we have to do is to pick a floating point
number at random, somewhere in the interval <tex>$\{-1, +1\}$</tex>.
I have done that in the following line:

 :include: .mkplummer1.rb-5

Here I have adapted the Ruby defined random number call +rand+ in the
following way, by defining a general floating point version +frand+:

 :inccode: .mkplummer1.rb+frand

Since +rand+ returns a value uniformly distributed throughout the
range <tex>$\{0, 1\}$</tex>, <tt>frand(a,b)</tt> returns a value
uniformly distributed throughout the range <tex>$\{a, b\}$</tex>.

*Alice*: And the next line is indeed just linear in the variable
<tex>$\phi$</tex>, where every point in the circle is equally likely
to be picked:

 :include: .mkplummer1.rb-6

*Bob*: And these values then get translated from spherical into
Cartesian coordinates in the usual way:

 :include: .mkplummer1.rb-7

*Alice*: Well, that wasn't too difficult.  I expect that choosing a velocity
may be a bit more tricky.

*Bob*: Indeed.  Aarseth <i>et al.</i> start with the observation that
the maximum velocity allowed at a radius _r_ is the escape velocity
<tex>$v_e(r)$</tex>, itself a function that depends on the radius.
The escape velocity can be determined by requiring that a particle at
radius _r_ has exactly zero total energy, <i>i.e.</i> its kinetic
energy is just enough for a parabolic escape to infinity.  Since the
potential energy for test particle moving in Plummer's model is given as

:equation:
U(r) \, = \, -\, {1\over \,\left(r^2 + 1\right)^{1/2}}

per unit mass, we can equate that to the kinetic energy, also per unit
mass, of a particle moving at the escape velocity:

:equation:
\half \left\{v_e(r)\right\}^2 \, + \, U(r) \, = \, 0 \, \Rightarrow

:equation:
\left\{v_e(r)\right\}^2  \, = \, 2\left(r^2 + 1\right)^{-1/2} \, \Rightarrow

:equation:
v_e(r)  \, = \, \sqrt{2} \left(r^2 + 1\right)^{-1/4}

This is the maximum velocity allowed at radius _r_, and we also know
that the minimum velocity at radius _r_ is zero.  The question is:
what is the probability distribution for <tex>$0\le v \le v_e$</tex>.

*Alice*: Ah, if you put it that way, the answer becomes easier: we have
to look at the distribution function for the energy of the particles:

:equation:
f(\br,\bv)d\br\bv \, = \, f(E(r,v)4\pi r^2 dr4\pi v^dv \, = \,
       {192\sqrt(2)\over7\pi}(-E)^{7/2}r^2v^2drdv

Hmm.  We now have to transform that into an equation for <tex>$v$</tex>.

*Bob*: If we compare particles with different velocities at a given point,
we know that their potential energies are all the same.  So the
probability to have an absolute value for the velocity
<tex>$v = |\bv|$</tex> at radial position <tex>$r = |\br|$</tex>
is given by

:equation:
g(v)dv \, \propto \, \left(-E(r,v)\right)^{7/2}v^2dv

Now the energy per unit mass <tex>$E(r,v) = U(r) + \half v^2$</tex>
can be written in terms of the escape velocity <tex>$v_e$</tex> as
<tex>$E(r,v) = -v_e^2 + \half v^2$</tex>.  If we introduce the
variable

:equation:
q \, = \, {v \over v_e}

we can write <tex>$E(q) \propto q^2 - 1$</tex>, for a given fixed
<tex>$r$</tex>.  The distribution function for <tex>$v$</tex> then
becomes, in terms of <tex>$q$</tex>, proportional to the following function:

:equation:
g(q) \, = \, \left(1 - q^2\right)^{7/2}q^2

*Alice*: And the range of admissable _q_ values is <tex>$0\le q \le 1$</tex>.
This looks exactly like the problem we had for determining the radial
positions.  There we knew the density, <i>i.e.</i> the probability function
to find a particle at a given position.  By integrating the density we
obtained the cumulative mass function <tex>$m(r)$</tex>, and then we
inverted that to obtain <tex>$r(m)$</tex>.

So I guess the next step is to integrate <tex>$g(q)$</tex>.  However, that
doesn't look so easy.

*Bob*: For the velocities, they choose a different approach.  If you plot
the function <tex>$g(q)$</tex>, then the height of that curve, for each
<tex>$q$</tex> value, gives you the relative probability that <tex>$q$</tex>
would lie in a region of small fixed width around that value.  You can
imagine that you can obtain a distribution of the required weighting
by throwing darts at that graph.  If you hit a point somewhere above
the graph, you throw a new dart, and you keep throwing new darts until
you hit a point below the graph, anywhere between <tex>$q=0$</tex> and
<tex>$q=1$</tex>.  If you follow that procedure, you are automatically
guaranteed that you score more hits at places where the graph is higher,
and exactly so in proportion to the height of a graph.

*Alice*: That is a clever solution.  It is called a rejection technique.
Didn't John von Neumann first apply that?  You start by allowing more
solutions than the minimal set of correct ones, and then you weed out
the incorrect ones, by rejecting them.

*Bob*: Indeed.  And to make the procedure efficient, you don't want to
throw darts way above the graph, so you limit yourself to the maximum
value that the graph attains in the interval of interest, or perhaps
a slightly higher value.  The authors of the paper choose a value of 0.1.

*Alice*: Is that a safe value?  Let's check for ourselves.  The derivative
of <tex>$g(q)$</tex> is

:eqnarray:
{dg(q)\over dq} \, &=& \, 
  2q\left(1 - q^2\right)^{7/2} -7q^3\left(1 - q^2\right)^{5/2}      \nonumber\\
&=& \, q\left(2 - 9 q^2\right)\left(1 - q^2\right)^{5/2}

To find the extrema for <tex>$g(q)$</tex>, we set the derative to zero,
and solve for <tex>$q_x$</tex>:

:equation:
q_x^2 = 2/9 \Rightarrow g(q_x) \, = \, (2/9)(7/9)^{7/2} \approx 0.092

Indeed: 0.1 is a rather tight upper limit.

*Bob*: Here is how I implemented this idea:

 :inccode: .mkplummer1.rb-8

*Alice*: I see.  So +x+ stands for <tex>$q$</tex> and +y+ stands for
<tex>$g(q)$</tex>.  You keep throwing darts until you find a +y+
value under the graph.  That gives you the corresponding +x+ value.
Since this value is equal to <tex>$q = v / v_e$</tex>, you have to
multiply +x+ with the escape velocity <tex>$v_e$</tex>, which we found
earlier to be:

:equation:
v_e(r)  \, = \, \sqrt{2}\left(r^2 + 1\right)^{-1/4}

Okay, I understand the procedure now.

*Bob*: And the procedure for picking random values for <tex>$\theta=0$</tex>
and <tex>$\phi$</tex>, and translating the velocity vector to
Cartesian coordinates, is just the same as it was in the case of the
position vector:

 :inccode: .mkplummer1.rb-9

I must admit, I'm glad you forced us to find a complete explanation
for everything.  I had basically just implemented their recipe, without
tracing the whole logic.

*Alice*: [some words of wisdom]

[MAKE SURE TO ADAPT THE DIALOGUE TO LET BOB STUMBLE ABOUT EXPLANATIONS]

== xxx

== xxx

== xxx

Write simplest <tt>mkplummer1.rb</tt>

learn to use (s)rand

check energy

check mass quartiles

subtract c.o.m. motion

cold start

== xxx


