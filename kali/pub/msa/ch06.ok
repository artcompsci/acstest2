= Running the Code

== A Surprise

*Carol*: Well, let's see what happens.  I don't want to look at a thousand
lines of output.  I will first run the code, redirecting the results into
an output file, called <tt>euler.our</tt>:

 :command: cp euler_elliptic.rb euler.rb
 :commandoutput: ruby euler.rb > euler.out

In that way, we can look at our leisure at the beginning and at the
end of the output file, while skipping the 991 lines in between:

 :commandoutput: head -5 euler.out
 :commandoutput: tail -5 euler.out

*Dan*: A lot of numbers.  Now what?  We'd better make a picture of the
results, to see whether these numbers make sense or not.  Let's plot the
orbit.

*Erica*: I agree, we should do that soon.  But hey, the numbers do tell us
something already, namely that there is something seriously wrong!

<b>* * * * * * *  This is how far I got, 2007/4/24  * * * * * * * </b>

*Carol*: Right you are, the numbers are much too large.  We are trying
to let two particles move around a circle, at a relative distance of 1.
However, here the separation in the <tex>$y$</tex> direction alone is
already larger than <tex>$11$</tex>, so the total separation must be
even larger.  I did not expect such a large error.

*Dan*: Hmmm, yes, that is rather surprising.  And yet, look, the result
of the very first step is exactly correct.  It is just what we would
expect, when scaling our earlier result, from a time step of
<tex>$dt=0.1$</tex> to a time step of <tex>$dt=0.01$</tex>.

*Erica*: Well, let us look at the orbit.  How do we make a plot?

*Carol*: I suggest using <tt>gnuplot</tt>, present on any Linux
running system, and something that can be easily installed on many
other systems as well.  The style is not particularly pretty, but at
least it will give us something to look at.

*Dan*: How do you invoke <tt>gnuplot</tt>?

*Carol*: To use it is quite simple, with only one command
needed to plot a graph.  In our case, however, I'll start with the
command <tt>set size ratio -1</tt>.  A positive value for the size
ratio scales the aspect ratio of the vertical and horizontal edge of
the box in which a figure appears.  But in our case we want to
set the scales so that the unit has the same length on both the x and
y axes.  Gnuplot can be instructed to do so by specifying the ratio to
be <tt>-1</tt>.  In fact, let me write the line <tt>set size ratio
-1</tt> in a file called <tt>.gnuplot</tt> in my home directory.  That
way we don't have to type it each time we use gnuplot.  Okay, done.
Now let's have our picture:

xxxxxxxxx

Let's plot it (fig ref(euler_circular_bug) ):

 gnuplot
 set size ratio -1
 plot "euler.out"
 quit

 :commandinput: gnuplot END
set term post eps
set output "euler_circular_bug.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_circular_bug.ps 10cm euler_circular_bug
First attempt at integrating the two-body problem: failure.

== For later: Integrating by One Step (Verification & Validation)

*Carol*: Yes, it looks reasonable.  But how do we know it really is
reasonable?

*Dan*: We can even check everything by hand.  Since we have initially

:equation:
\br(0) = \{x, y, z\} = \{1,0,0\}

and

:equation:
\bv(0) = \{v_x, v_y, v_z\} = \{0,1,0\}

the new position must be:

:equation:
\br(dt) = \br + \bv dt = \{1,dt,0\}

*Carol*: And this is indeed what we see in the first half of the last output
line.

*Dan*: To compute the new velocity, we have to first compute the
acceleration vector.  Let's see, Newton's equation of motion for the
two-body problem, as written above in component form, gives simply:

:equation:
\ba = \{a_x, a_y, a_z\} = \{-1,0,0\}

This means that

:equation:
\bv(dt) = \bv + \ba dt = \{-dt,1,0\}

*Erica*: And this is indeed what is printed in the last half of the last
output line.

*Dan*: Perfect!

*Carol*: Well, sort-of.  We have verified that our program does what the
algorithm intended, and that is certainly nice!  But this is only half
of the work.  We now have to check whether this particular algorithm
does indeed give a reasonable result, which corresponds to the behavior
of gravitating particles in the real world.  This is called validation.
In the computer science literature these two checks are often called 
V&V, for Verification and Validation.

In other words, we have passed the verification test, so now we have
to do a validation test.  For example, we can ask whether this first
step keeps the two particles on a circular orbit.  After the first
step, the new separation is:

:equation:
r(0.1) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.1^2} = \sqrt{1.01} \approx 1.005

*Dan*: Instead of the correct value of <tex>$r(0.1)=1$</tex>, we are half a
percent off.  Not bad, I would say.

*Carol*: Not bad for one step, perhaps, but our orbit has a radius of unity,
which means a circumference of <tex>$2\pi \approx 6.3$</tex>.  With a velocity
of unity, it will take <tex>$63$</tex> steps to go around the circle,
at the rate we are going.  And if every step introduces `only' half a percent
error, and if the errors built up linearly, we wind up with a total error of
more than 30%, even during the first revolution!

*Dan*: Good point.  Of course, we don't know whether the errors build up
linearly, but for lack of a better idea, that would be the first guess.
Perhaps we should take a smaller time step.  What would happen if we would
use <tex>$dt = 0.01$</tex>?  Let's repeat your analysis.  After one step,
we would have

:equation:
r(0.01) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.01^2} = \sqrt{1.0001}
\approx 1.00005

We now need roughly <tex>$630$</tex> steps to go around the circle,
If the errors build up linearly, the radial separation will grow to
something like <tex>$1 + 630*0.00005 \approx 1.03$</tex>.  Aha!  Only
a 3% error, instead of roughly 30%.

*Erica*: Bravo!  You have just proved that the forward Euler scheme is
a first-order scheme!  Remember our discussion at the start?  For a
first-order scheme, the errors scales like the first power of the time
step.  You just showed that taking a time step that is ten times smaller
leads to a ten times smaller error after completing one revolution.

*Dan*: Great!  I thought that numerical analysis was a lot harder.

*Carol*: Believe me, it _is_ a lot harder for any numerical integration
scheme that is more complex than first-order.  You'll see!

*Dan*: I can wait.  For now I'm happy to work with a scheme which I can
completely understand.  On to the next step!  And ah, yes, let us take
steps with a size <tex>$dt = 0.01$</tex>, given what we've just learned.

== for Later: the circular bug discussion

*Carol*: I don't think you would like to read through 1001 lines of output.
Let's run the code while redirecting the output to a file 

 :command: cp euler_circular_bug.rb euler.rb
 :commandoutput: ruby euler.rb > euler.out

We can then have a peek at, say, the first five lines and the last
five lines, while skipping the 991 lines in between:

 :commandoutput: head -5 euler.out
 :commandoutput: tail -5 euler.out

*Dan*: Instead of a bunch of numbers, I'd rather see a plot of the orbit.

*Erica*: I agree, we should do that soon.  But hey, the numbers do tell us
something already, namely that there is something seriously wrong!

*Carol*: Right you are, the numbers are much too large.  We are trying
to let two particles move around a circle, at a relative distance of 1.
However, here the separation in the <tex>$y$</tex> direction alone is
already larger than <tex>$11$</tex>, so the total separation must be
even larger.  I did not expect such a large error.

*Dan*: Hmmm, yes, that is rather surprising.  And yet, look, the result
of the very first step is exactly correct.  It is just what we would
expect, when scaling our earlier result, from a time step of
<tex>$dt=0.1$</tex> to a time step of <tex>$dt=0.01$</tex>.

*Erica*: Well, let us look at the orbit.  How do we make a plot?

*Carol*: I suggest using <tt>gnuplot</tt>, present on any Linux
running system, and something that can be easily installed on many
other systems as well.  The style is not particularly pretty, but at
least it will give us something to look at.

*Dan*: How do you invoke <tt>gnuplot</tt>?

*Carol*: To use it is quite simple, with only one command
needed to plot a graph.  In our case, however, I'll start with the
command <tt>set size ratio -1</tt>.  A positive value for the size
ratio scales the aspect ratio of the vertical and horizontal edge of
the box in which a figure appears.  But in our case we want to
set the scales so that the unit has the same length on both the x and
y axes.  Gnuplot can be instructed to do so by specifying the ratio to
be <tt>-1</tt>.  In fact, let me write the line <tt>set size ratio
-1</tt> in a file called <tt>.gnuplot</tt> in my home directory.  That
way we don't have to type it each time we use gnuplot.  Okay, done.
Now let's have our picture:

xxxxxxxxx

Let's plot it (fig ref(euler_circular_bug) ):

 gnuplot
 set size ratio -1
 plot "euler.out"
 quit

 :commandinput: gnuplot END
set term post eps
set output "euler_circular_bug.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_circular_bug.ps 10cm euler_circular_bug
First attempt at integrating the two-body problem: failure.

== Debugging

xxxxx

== Much Better

Corrected code <tt>euler_circular.rb</tt>, but we show it as if it is called
<tt>euler.rb</tt>:

 :inccode: .euler_circular.rb

Let's run it:

 :command: cp euler_circular.rb euler.rb
 :commandoutput: ruby euler.rb > euler.out
 :commandoutput: head -5 euler.out
 :commandoutput: tail -5 euler.out

Let's plot it:

 :commandinput: gnuplot END
set term post eps
set output "euler_circular.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_circular.ps 10cm euler_circular
Second attempt at integrating the two-body problem: looking a lot better.

