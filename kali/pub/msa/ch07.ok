= Debugging the Code

== One Integration Step: Verification

*Carol*: Here we go, taking just a single step . . .

 :commandoutput: ruby euler_circular_step.rb

*Dan*: . . . and getting just one short new line of output, after
the initial conditions are echoed.  But it seems too simple!
Previously, we got much more complicated lines of output.

*Carol*: Well, yes, but did we got those right away?  Let me check.
Good thing we kept the old program, and give the new one a new name.
Let me reproduce the first four lines of the old program:

 :command: cp euler_elliptic.rb euler.rb
 :commandoutput: ruby euler.rb | head -4

*Dan*: I see, I was wrong.  The first step gave a simple answer,
also in the previous case; it was after the second step that rather
complicated numbers showed up.

*Erica*: Time to check whether our first step is correct!  We start
with

:equation:
\br(0) = \{x, y, z\} = \{1,0,0\}

and

:equation:
\bv(0) = \{v_x, v_y, v_z\} = \{0,1,0\}

so the new position must be:

:equation:
\br(dt) = \br + \bv dt = \{1,dt,0\}

*Carol*: And this is indeed what we see in the first half of the second
output line.

*Dan*: Yes, in both cases: for our new one-step program we got the correct
result with <tt>v=1</tt> and for our old program we got the correct result
with <tt>v=0.5</tt>, given that in both cases we choose <tt>dt=0.01</tt>.
That is encouraging!  What about the second half of the second output lines?

*Erica*: To compute the new velocity, we have to first compute the
acceleration vector.  We can use Eq. (ref(Newton2bodysimple)), which
I'll copy here once again:

:equation:
\ba = - \frac{\br}{r^3}

In our case this gives

:equation:
\ba = \{a_x, a_y, a_z\} = \{-1,0,0\}

And this in turn means that

:equation:
\bv(dt) = \bv + \ba dt = \{-dt,1,0\}

*Carol*: And this is indeed what is printed in the last half of the last
output line, in our one-step program.  For our previous program, we have
to remember that the initial velocity was only half as large, which gives
<tex>$\bv(dt) = \{-dt,0.5,0\}$</tex> which is indeed what we got.

*Dan*: Perfect.

== One Integration Step: Validation

*Carol*: Well, sort-of.  We have verified that our program does what the
algorithm intended, and that is certainly nice!  But this is only half
of the work.  We now have to check whether this particular algorithm
does indeed give a reasonable result, which corresponds to the behavior
of gravitating particles in the real world.  This is called validation.
In the computer science literature these two checks are often called 
V&V, for Verification and Validation.

In other words, we have passed the verification test.  The computer
code does exactly what we wanted it to do, at least for one step.  But
now we have to do a validation test.  For example, we can ask whether
this first step keeps the two particles on a circular orbit.  After
the first step, the new separation is:

:equation:
r(0.1) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.01^2} = 
\sqrt{1.0001} \approx 1.00005

*Dan*: Instead of the correct value of <tex>$r(0.01)=1$</tex>, we are half a
one hundredth of one percent off.  Not bad, I would say.

*Carol*: Not bad for one step, perhaps, but our orbit has a radius of unity,
which means a circumference of <tex>$2\pi \approx 6.3$</tex>.  With a velocity
of unity, it will take <tex>$630$</tex> steps to go around the circle,
at the rate we are going.  And if every step introduces `only' an
error of <tex>$0.00005$</tex>, and if the errors built up linearly, we
wind up with a total error of <tex>$1 + 630*0.00005 \approx 1.03$</tex>.
That is already a 3% error, even during the first revolution!  And after
just a few dozen revolutions, if not earlier, the results will be meaningless.

*Dan*: Good point.  Of course, we don't know whether the errors build up
linearly, but for lack of a better idea, that would be the first guess.
Perhaps we should take an even smaller time step.  What would happen
if we would use <tex>$dt = 0.001$</tex>?  Let's repeat your analysis.
After one step, we would have

:equation:
r(0.001) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.001^2} = \sqrt{1.000001}
\approx 1.0000005

We now need roughly <tex>$6300$</tex> steps to go around the circle,
If the errors build up linearly, the radial separation will grow to
something like <tex>$1 + 6300*0.0000005 \approx 1.003$</tex>.  Aha!  Only
a 0.3% error, instead of 3%.

*Erica*: Bravo!  You have just proved that the forward Euler scheme is
a first-order scheme!  Remember our discussion at the start?  For a
first-order scheme, the errors scale like the first power of the time
step.  You just showed that taking a time step that is ten times smaller
leads to a ten times smaller error after completing one revolution.

*Dan*: Great!  I thought that numerical analysis was a lot harder.

*Carol*: Believe me, it _is_ a lot harder for any numerical integration
scheme that is more complex than first-order.  You'll see!

*Dan*: I can wait.  For now I'm happy to work with a scheme which I can
completely understand.

== More Integration Steps

*Carol*: So were are we.  To sum up: we have verified that our
simple one-step code <tt>euler_circular_step.rb</tt> does exactly what
we want it to do.  And we have validated that what we want it to do is
reasonable: for smaller and smaller time steps the orbit should stay
closer and closer to the true circular orbit.

*Dan*: That's the good news.  But at the same time, that's also the bad
news!  When we tried to integrate an arbitrary elliptical orbit, we got
a nonsence picture.  So then we tried to make life simpler, to see what
went wrong.  But we have not found anything that went wrong!  How come?

*Erica*: We'll have to work our way up to the more complicated situation.
Let us stick to the circular orbit for now.  We have a basis to start from:
the first step was correct, that we know for sure.  Let's do a few more steps.

*Dan*: How about a hundred steps?

*Erica*: Why not.  Let us go back to the very first code we wrote, but
now for a circular orbit, and for an integration of one time unit, which
will give us a hundred steps.

*Carol*: Let's keep the old code, for comparison.  Here is the new one.
I will call it <tt>euler_circular_100_steps.rb</tt>:

 :inccode: .euler_circular_100_steps.rb

*Dan*: If you keep making the names longer and longer, they won't fit on
a single line anymore!

*Carol*: You do what you want and I do what I want; I just happen to sit
behind the keyboard.

*Erica*: Peace, peace!  Let's not fight about names; we can later make
copies with shorter names as much as we like.

 :commandoutput: ruby euler_circular_100_steps.rb > euler.out

 gnuplot
 set size ratio -1
 plot "euler.out"
 quit

 :command: ruby euler_circular_100_steps.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "euler_circular_100.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_circular_100.ps 10cm euler_circular_100
Second attempt at integrating the two-body problem: looking reasonable.

*Dan*: Figure ref(euler_circular_100) is still too good to be true;
looks like the orbit is perfectly circular, as far as the eye can see.
We're supposed to find a bug, but everything just keeps going fine.
We have a problem, in that we don't find a problem!

== Even More Integration Steps

*Erica*: Let's try to be more systematic.  We tried one step, and then
we tried a hundred steps.  But our very first problem showed up after
a thousand steps.  I'd like us to try a thousand steps here too.

*Dan*: What difference can that possibly make?

*Carol*: That's my reaction too, but what the heck,
if Erica asks for it, we'll give it to her.
Let's make yet another new file . . . Dan,
close your eyes, I'm adding one more
character to the file name . . . <tt>euler_circular_1000_steps.rb</tt>:

 :inccode: .euler_circular_1000_steps.rb

*Dan*: no comment.

*Carol*: And here is our little present for Erica,
which we'll call figure ref(euler_circular_1000):

 :commandoutput: ruby euler_circular_1000_steps.rb > euler.out

 gnuplot
 set size ratio -1
 plot "euler.out"
 quit

 :command: ruby euler_circular_1000_steps.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "euler_circular_1000.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_circular_1000.ps 10cm euler_circular_1000
Third attempt at integrating the two-body problem: a different failure.

*Dan*: Whoa, some little present!

*Erica*: I'd say!

*Carol*: And I will never question Erica's demands anymore.  That's awesome!

<b>* * * * * * *  This is how far I got, 2007/5/1  * * * * * * * </b>
