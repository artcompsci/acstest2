= A Complete +Vector+ Class

== +Vector+ Subtraction

*Erica*: Well, Carol, you've pulled a really neat trick.  What a difference,
being able to add vectors by writing

  v = v1 + v2

rather than 

  v = []
  v1.each_index{|k| v[k] = v1[k] + v2[k]}

*Dan*: Thanks, Carol!  You've just made our life a whole lot easier.

*Carol*: Not quite yet; I'll have to do the same thing for subtraction,
multiplication and addition as well.  And I'm sure there are a few more
things to consider, before we can claim to have a complete +Vector+ clss.
But I, too, am encouraged with the good start we've made!

I'll open a new file <tt>vector_try_add_sub.rb</tt>.  First thing to add,
after addition, is subtraction.  That part is easy:

 :inccode: .vector_try_add_sub.rb

*Erica*: So now we can write <tt>v = v1 + v2</tt> and <tt>v = v1 - v2</tt>
But what about <tt>v = -v1</tt>?  Or even just <tt>v = v1</tt>?  Would that
work too?

*Carol*: Good question!  Probably not.  But before getting into the why not,
let's play with +irb+ and see what happens:

 :commandinputoutputnoecho: irb END
require "vector_try_add_sub.rb"
v1 = Vector[1, 2, 3]
v2 = Vector[5, 6, 7]
v = v1 + v2
v = v1 - v2
v = v1
v = -v1
quit
END

*Dan*: Huh?  A method by the name of a minus sign followed by an
<tt>@</tt> symbol?  That's the strangest method name I've ever seen.
And what can it mean that it is undefined?  Should it be defined?

*Erica*: At least writing <tt>v = v1</tt> worked.  So we've come halfway!

*Dan*: Ah, but would it also work if we would write <tt>v = +v1</tt>?
Let me try:

 :commandinputoutputnoecho: irb END
require "vector_try_add_sub.rb"
v1 = Vector[1, 2, 3]
v2 = Vector[5, 6, 7]
v = +v1
quit
END

Aha!  You see, we're not even half-way yet.  Neither of the two work.
But it's intriguing that we get a similar error message, this time with
a plus sign in front of the mysterious <tt>@</tt> symbol.

== Unitary <tt>+</tt> and <tt>-</tt>

*Carol*: Let me consult the Ruby manual.  Just a moment . . . aha, I see!
Well, this is perhaps an exception to Ruby's principle of least surprise.
The manual tells me that <tt>+@</tt> is the Ruby notation for a
unitary minus.

*Dan*: A unitary minus?

*Carol*: Yes, and the word `unit' in unitary here means `one'.  A unitary
minus is an operation that has only one operand.

*Erica*: As opposed to what?

*Carol*: As opposed to a binary minus.  Most normal operations, such as 
addition and substraction, as well as multiplication and division, are
binary operation.  Binary here means two operands.  When you use a
single plus sign, you add two numbers.  Similarly, a minus allows you
to subtract two numbers.  So when you write <tt>5 - 3 = 2</tt> you are using
a binary minus.  However, when you first write <tt>x = 5</tt> and then
<tt>y = -x</tt>, to give <tt>y</tt> the value <tt>-5</tt>, you are using
not a binary minus, but a unary minus.  The construction <tt>-x</tt>
returns a value that has the value of the variable <tt>x</tt>, but with
an additional minus sign.

*Dan*: So you are effectively multiplying <tt>x</tt> with the number
<tt>-1</tt>.

*Erica*: Or you could say that you are subtracting <tt>x</tt> from <tt>0</tt>.

*Carol*: Yes, both statements are correct.  But rather than introducing
multiplication, it is simpler to think only about subtraction.  So writing
<tt>-x</tt> uses a unary minus, while writing <tt>0-x</tt> uses a binary
minus, while both are denoting the same result.

*Dan*: But why does Ruby use such a complicated symbol, <tt>+@</tt>, for
unitary minus?

*Carol*: That symbol is only used when you redefine the symbol.  We have
just redefined the binary plus as follows:

 :inccode: .vector_try.rb-binplus

<b>[ this is how far I got ; 2007/8/2 -- Piet ]</b>

== +Vector+ Multiplication

multiplication.

In fact, there are two types of multiplication that we have to consider.

With <tt>vector_try.rb</tt>: 

 :inccode: .vector_try.rb

And with <tt>euler_modified_vector_try.rb</tt>:

 :inccode: .euler_modified_vector_try.rb

 :commandoutput: ruby euler_modified_vector_try.rb | tail -1

With <tt>euler_modified_vector_try_again.rb</tt>:

 :inccode: .euler_modified_vector_try_again.rb

 :commandoutput: ruby euler_modified_vector_try_again.rb | tail -1

Now with <tt>vector.rb</tt>: 

 :inccode: .vector.rb

And with <tt>euler_modified_vector.rb</tt>:

 :inccode: .euler_modified_vector.rb

 :commandoutput: ruby euler_modified_vector.rb | tail -1

Let integer division give floating point results, where needed
