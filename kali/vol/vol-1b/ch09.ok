= A Four-Step Method

== Combinatorics

*Bob*: Ready to go for a fourth-order multi-step algorithm?

*Alice*: Ready whenever you are!

*Bob*: I'll start by repeating the steps I showed you for the second-order
algorithm.  Instead of Eq. (ref(firstacctaylor)), we now have to expand
the acceleration in a Taylor series up to the crackle:

:equation:
\label{secondacc}
\ba \,=\, \ba_0 + \bj_0 t + \hhalf \bs_0 t^2
+ \one{6} \bc_0 t^3 + O(t^4)

And instead of Eq. (ref(prevacc)) for the previous value of the acceleration,
we now need to remember _three_ previous values:

:eqnarray:
\label{threea}
\ba_{-1} \,&=&\,
\ba_0 - \bj_0 \Delta t + \hhalf \bs_0 (\Delta t)^2
- \one{6} \bc_0 (\Delta t)^3                        \nonumber\\
\ba_{-2} \,&=&\,
\ba_0 - 2\bj_0 \Delta t + 2 \bs_0 (\Delta t)^2
 - {\textstyle\frac{4}{3}} \bc_0 (\Delta t)^3       \nonumber\\
\ba_{-3} \,&=&\,
\ba_0 - 3\bj_0 \Delta t + {\textstyle\frac{9}{2}} \bs_0 (\Delta t)^2
 - {\textstyle\frac{9}{2}} \bc_0 (\Delta t)^3

*Alice*: And these we have to invert, in order to regain the three
values for <tex>$\bj_0$</tex>, <tex>$\bs_0$</tex> and <tex>$\bc_0$</tex>,
which we can then use in Eq. (ref(secondacc)).  The only difference is
that the inversion is a little harder than it was for getting
Eq. (ref(firstjerk)).

*Bob*: Just a little.  Good luck!

*Alice*: Oh, I have to do it again?  Well, I guess I sort-of like doing
this, up to a point.

*Bob*: And if you dislike it, you certainly dislike it far less than I do.

*Alice*: Okay, I'll do it.  From Eq. (ref(threea)) we can form the following
linear combination, subtracting the second equation from twice the
first one, in order to eliminate the term with the jerk in it.  Similarly,
we can subtract the third equation from thrice the first one, and we wind
up with two equations for the two remaining variables, the snap
<tex>$\bs_0$</tex> and the crackle <tex>$\bc_0$</tex>:

:eqnarray:
\label{twoa}
2\ba_{-1} - \ba_{-2} \,&=&\,
\ba_0 -  \bs_0 (\Delta t)^2 + \bc_0 (\Delta t)^3       \nonumber\\
3\ba_{-1} - \ba_{-3} \,&=&\,
2\ba_0 -  3\bs_0 (\Delta t)^2 + 4\bc_0 (\Delta t)^3

The next step is to eliminate <tex>$\bs_0$</tex>, in order to obtain
an equation for <tex>$\bc_0$</tex>, as follows:

<tex>$$
3\left( 2\ba_{-1} - \ba_{-2} \right) - \left( 3\ba_{-1} - \ba_{-3} \right)
\,=\, \ba_0 -  \bc_0 (\Delta t)^3   \,\,\,\,\Rightarrow
$$</tex>

<tex>$$
3\ba_{-1} - 3\ba_{-2} +  \ba_{-3}
\,=\, \ba_0 -  \bc_0 (\Delta t)^3   \,\,\,\,\Rightarrow
$$</tex>

:equation:
\label{bc}
\bc_0 \,=\, {1\over (\Delta t)^3}\left\{
\ba_0 -3\ba_{-1} + 3\ba_{-2} - \ba_{-3}
\right\}

*Bob*: One down, two to go!

*Alice*: Each next one will only get easier.  I'll substitute Eq. (ref(bc))
in the top line of Eq. (ref(twoa)), and that should do it:

:eqnarray:
\bs_0(\Delta t)^2 \,&=&\, 
-2\ba_{-1} + \ba_{-2} + \ba_0 + \bc_0 (\Delta t)^3 \nonumber\\
&=&\,
-2\ba_{-1} + \ba_{-2} + \ba_0 + 
\left\{
\ba_0 -3\ba_{-1} + 3\ba_{-2} - \ba_{-3}
\right\}\,\,\,\,\Rightarrow \nonumber

:equation:
\label{bs}
\bs_0 \,=\, {1\over (\Delta t)^2}\left\{
2\ba_0 -5\ba_{-1} + 4\ba_{-2} - \ba_{-3}
\right\}

You see, now that wasn't that hard, was it?

*Bob*: Not if you do it, no.  Keep up the good work!

*Alice*: Now for the home run.  I'll substitute Eqs. (ref(bc)) and (ref(bs))
in the top line of Eq. (ref(threea)), and get:

:eqnarray:
\bj_0 \Delta t \,\,\,=\,\,\, -\ba_1 \,\,+\,\, \ba_0 &+&
\hhalf \bs_0(\Delta t)^2 -\one{6} \bc_0(\Delta t)^3          \nonumber\\
-\ba_1 \,\,+\,\, \ba_0 &+&
\left\{
\ba_0 -{\textstyle\frac{5}{2}}\ba_{-1} + 2\ba_{-2} - \hhalf\ba_{-3}
\right\}             \nonumber\\
&+&
\left\{
-\one{6}\ba_0 +\hhalf\ba_{-1} -\hhalf\ba_{-2} +\one{6} \ba_{-3}
\right\}\,\,\,\,\Rightarrow           \nonumber

:equation:
\label{bj}
\bj_0 \,=\, {1\over \Delta t}\left\{
{\textstyle\frac{11}{6}}\ba_0 -3\ba_{-1} + \three{2}\ba_{-2} - \one{3}\ba_{-3}
\right\}

So here are the answers!

*Bob*: If you didn't make a mistake anywhere, that is.

== Checking

*Alice*: I thought it was your job to check whether I was not making any
mistake!

*Bob*: I _think_ you didn't make any.  But as you so often say, it doesn't
hurt to check.

*Alice*: I can't very well argue with myself, can I?  Okay, how shall we
check things.  Doing the same things twice is not the best way to test my
calculations, since I may well make the same mistake the second time, too.

It would be much better to come up with an independent check.  Ah, I
see what we can do: in Eq. (ref(threea)), I can check whether the solutions
I just obtained for for <tex>$\bj_0$</tex>, <tex>$\bs_0$</tex> and
<tex>$\bc_0$</tex> indeed give us those previous three accelerations back
again.  In each of those three cases, I'll start off with the right-hand
sides of the equation, to see whether I'll get the left-hand side back.

Here is the first one:

:eqnarray:
&&\ba_0 - \bj_0 \Delta t + \hhalf\bs_0 (\Delta t)^2
- \one{6} \bc_0 (\Delta t)^3 \,\,=                                  \nonumber\\
&&                                                                  \nonumber\\
&&\,\,\,\,\,\,+\ba_0                                                \nonumber\\
&&-{\textstyle\frac{11}{6}}\ba_0 +3\ba_{-1} - \three{2}\ba_{-2}
  + \one{3}\ba_{-3}                                                 \nonumber\\
&&\,\,\,\,\,\, +\ba_0
  -{\textstyle\frac{5}{2}}\ba_{-1} + 2\ba_{-2} -\hhalf\ba_{-3}\nonumber\\
&&\,\,-\one{6}\ba_0 +\hhalf\ba_{-1}
  -\hhalf\ba_{-2} +\one{6}\ba_{-3}\,\,\,=\,\,\, \ba_{-1}         \nonumber

*Bob*: Good start!

:eqnarray:
&&\ba_0 - 2\bj_0 \Delta t + 2 \bs_0 (\Delta t)^2
 - {\textstyle\frac{4}{3}} \bc_0 (\Delta t)^3\,\,=                  \nonumber\\
&&                                                                  \nonumber\\
&&\,\,\,\,\,\,+\ba_0                                       \nonumber\\
&&-{\textstyle\frac{11}{3}}\ba_0 \,+\,6\ba_{-1} - 3\ba_{-2}
  + {\textstyle\frac{2}{3}}\ba_{-3}                                 \nonumber\\
&&\,\,\, +4\ba_0
  -10\ba_{-1} + 8\ba_{-2} -2\ba_{-3}\nonumber\\
&&\,\,-{\textstyle\frac{4}{3}}\ba_0 \,\,+\,4\ba_{-1}
  -4\ba_{-2} +{\textstyle\frac{4}{3}}\ba_{-3}\,\,\,=\,\,\, \ba_{-2}  \nonumber

*Alice*: And a good middle part, too.  Now for the finish:

:eqnarray:
&&\ba_0 - 3\bj_0 \Delta t + {\textstyle\frac{9}{2}} \bs_0 (\Delta t)^2
 - {\textstyle\frac{9}{2}} \bc_0 (\Delta t)^3\,\,=                  \nonumber\\
&&                                                                  \nonumber\\
&&\,\,\,\,\,\,\,\,\,\,\,\ba_0                                       \nonumber\\
&&-{\textstyle\frac{11}{2}}\ba_0 \,\,+\,\,9\ba_{-1}
 \,-\, {\textstyle\frac{9}{2}}\ba_{-2}
  \,+\,\ba_{-3}                                                    \nonumber\\
&&\,\,\,\, +9\ba_0
  -{\textstyle\frac{45}{2}}\ba_{-1} + 18\ba_{-2}
  -{\textstyle\frac{9}{2}}\ba_{-3}\nonumber\\
&&\,\,\,-{\textstyle\frac{9}{2}}\ba_0 +{\textstyle\frac{27}{2}}\ba_{-1}
  -{\textstyle\frac{27}{2}}\ba_{-2} +{\textstyle\frac{9}{2}}\ba_{-3}
  \,\,\,=\,\,\, \ba_{-3}  \nonumber

Good!  Clearly, the expressions in Eqs. (ref(bj)), (ref(bs)) and (ref(bc))
are correct.  Phew!  And now that that is done . . . what was it again
we set out to do?

*Bob*: We were trying to get an expression for the acceleration at time
zero, to third order in the time step, expressed in terms of the previous
three accelerations.  So all we have to do is to plug your results back
into Eq. (ref(secondacc)).

*Alice*: Ah, yes, it's easy to forget the thread of a story, if you get lost
in eliminations.

== Implementation

*Bob*: So now it's my turn, I guess.  Let me code up your results.  I'll open
a new file, <tt>ms4body.rb</tt>.  Let me first have a look at the
previous second-order method <tt>ms2</tt>, for comparison:

 :inccode: .ms4body.rb+ms2

Our fourth-order multi-step method should be called <tt>ms4</tt>,
clearly.  I'll use <tt>rk4</tt> to rev up the engine, something we'll
have to do three times now.  And instead of use snap and crackle
out-of-the-box, so to speak, I'll use them with the appropriate factors
of the time step, <tex>$\bs(\Delta t)^2$</tex> and
<tex>$\bc(\Delta t)^3$</tex>, respectively.

Here are the equations that we have to code up, as a generalization of
Eq. (ref(ms)):

:eqnarray:
\label{ms4}
\br_1 &=& \br_0 + \bv_0 \Delta t + \hhalf \ba_0 (\Delta t)^2
+ \one{6}\bj_0 (\Delta t)^3 + \one{24}\bs_0 (\Delta t)^4           \nonumber\\
\bv_1 &=& \bv_0 + \ba_0 \Delta t + \hhalf \bj_0 (\Delta t)^2
+ \one{6}\bs_0 (\Delta t)^3 + \one{24}\bc_0 (\Delta t)^4

Here is my implementation:

 :inccode: .ms4body.rb+ms4

*Alice*: That's not so much longer than <tt>ms2</tt>, and it still looks
neat and orderly!  And wait, you have used the division method for our
+Vector+ class, in dividing by those number like <tex>$6.0$</tex> and
so on.

*Bob*: That's true!  I hadn't even thought about it; it was so natural
to do that.  What did you say again, when I told you I had added division,
together with subtraction, to the +Vector+ class?

*Alice*: I said that I was sure it would come in handy sooner or later.

*Bob*: I guess it was sooner rather than later.

*Alice*: And I see that you have abbreviated the names of the variables
somewhat.  Instead of <tt>@prev_acc</tt> for the previous acceleration,
you now use <tt>@ap1</tt>, for the first previous acceleration, I guess.
And then, for the yet more previous acceleration before that, you use
<tt>@ap2</tt>, and so on.

*Bob*: Yes.  I would have like to write <tt>a-2</tt> for <tex>$a_{-2}$</tex>
but that would be interpreted as a subtraction of the number
<tt>2</tt> from the variable +a+, so I choose <tt>@ap2</tt>, for
<i>a-previous-two</i>.

== Testing

*Alice*: Time to test <tt>ms4</tt>.

*Bob*: Yes, and we may as well start again with the
same values as we have been using recently:

 :commandoutput: ruby integrator_driver4d.rb < euler.in

A good start.  Now for time steps that are ten times smaller:

 :commandoutput: ruby integrator_driver4e.rb < euler.in

*Alice*: Congratulations!  But this is close to machine accuracy.
Can you just double the time step, to check whether the errors get
16 times larger?

 :commandoutput: ruby integrator_driver4f.rb < euler.in

*Bob*: There you are!  We indeed have a fourth-order multi-step integrator!

== A Predictor-Corrector Version

*Alice*: Now that everything works, how about trying the apply a
corrector loop?  In the case of your second-order version, we saw
that there was no need to bother doing so, since we convinced ourselves
that we just got the leapfrog method back.  But that must have been a
low-order accident.  The fourth-order predictor-corrector version will
surely lead to a new algorithm, one that you haven't already implemented
in our N-body code.

*Bob*: I'm sure you're right.  Okay, let's!

*Alice*: Given that I already reconstructed your instructions on paper before,
I only have to extend it to two orders higher.  Here are the results
on a backward extrapolation, starting with the predicted values at time
<tex>$t=1$</tex>, and going back to time <tex>$t=0$</tex>:

:eqnarray:
\tilde\br_0 &=& \br_1 + \bv_1 (-\Delta t) + \hhalf \ba_1 (-\Delta t)^2
+ \one{6}\bj_1 (-\Delta t)^3 + \one{24}\bs_1 (-\Delta t)^4          \nonumber\\
\tilde\bv_0 &=& \bv_1 + \ba_1 (-\Delta t) + \hhalf \bj_1 (-\Delta t)^2
+ \one{6}\bs_1 (-\Delta t)^3 + \one{24}\bc_1 (-\Delta t)^4

which lead to the corrected versions of position and velocity as follows:

:eqnarray:
\bv_{c,1} &=& \bv_0 + \ba_{p,1} \Delta t - \hhalf \bj_{p,1} (\Delta t)^2
+ \one{6}\bs_{p,1} (\Delta t)^3 - \one{24}\bc_{p,1} (\Delta t)^4    \nonumber\\
\br_{c,1} &=& \br_0 + \bv_{c,1} \Delta t - \hhalf \ba_{p,1} (\Delta t)^2
+ \one{6}\bj_{p,1} (\Delta t)^3 - \one{24}\bs_{p,1} (\Delta t)^4 

where again <tex>$\ba_{p,1}= \ba(\br_{p,1})$</tex> and where
<tex>$\bj_{p,1}$</tex>, <tex>$\bs_{p,1}$</tex>, and <tex>$\bc_{p,1}$</tex>
are the jerk, snap, and crackle as determined from the values of the last
four accelerations, which are now
<tex>$\left\{\ba_{-2},\ba_{-1},\ba_0,\ba_{p,1}\right\}$</tex>, instead of
the previous series of four that were used in the prediction step, which were
<tex>$\left\{\ba_{-3},\ba_{-2},\ba_{-1},\ba_0\right\}$</tex>.

Note that once more I have interchanged the order of the calculations of
the position and velocity: by calculating the corrected value of the velocity
first, I am able to use that one in the expression for the corrected value
of the position.

*Bob*: And this time I certainly do not recognize these equations.  It
seems that we really have a new algorithm here.

*Alice*: Let me see whether I can extend your code, to implement this scheme.
It would be nice to keep the number of acceleration calculations the same
as we had before, doing it only once per time step.  After all, when
we will generalize this to a true N-body system, it is the calculation
of the acceleration that will be most expensive, given that for each particle
we will have to loop over all other particles.

However, I need to compute the acceleration at the end of the calculation,
at the newly predicted position.  This means that I then have to remember
the value of the acceleration, so that I could reuse it at the
beginning of the next time step.  This means that I will have to change
the variable <tt>ap0</tt> to a true instance variable <tt>@ap0</tt>, so
that it will still be there, the next time we enter <tt>ms4pc</tt>.

I will have to initialize <tt>@ap0</tt> during the last time we use the
<tt>rk4</tt> method, so that it is ready to be used when we finally
enter the main body of the <tt>ms4pc</tt> method, as I will call it,
to distinguish it from your previous implementation <tt>ms4</tt>.
The +pc+ stands for predictor-corrector version.

Well, the rest is just a matter of coding up the equations we just
wrote out.  What do you think of this:

 :inccode: .ms4body.rb+ms4pc

*Bob*: That ought to work.  Let's see whether it does:

 :commandoutput: ruby integrator_driver4dpc.rb < euler.in

*Alice*: Much better!  More than ten times more accurate than the
predictor-only version, the method <tt>ms4</tt>.  Let me give a
ten times smaller time step:

 :commandoutput: ruby integrator_driver4epc.rb < euler.in

Even better, by a factor of about twenty this time.  Great!
I now feel I understand the idea of predictor-corrector schemes.
We're building up a good laboratory for exploring algorithms!

*Bob*: Yes, I've never been able to plug and play so rapidly with different
integration schemes.  Using a scripting language like Ruby definitely has
its advantages.
