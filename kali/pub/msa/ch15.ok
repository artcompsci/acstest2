= Second-Order Algorithms

== Modified Euler

*Dan*: Now that we have a vector version of forward Euler, it's time
to clean up our modified Euler code as well.

*Carol*: That will be an easy translation.  I'll open a new file,
<tt>euler_modified_vector.rb</tt>, and I will copy the code from
<tt>euler_modified_array.rb</tt>, while translating from array notation
to vector notation.  Same ideas as with <tt>euler_vector.rb</tt>.
Here it is:

 :inccode: .euler_modified_vector.rb

*Erica*: What a relief!  The lines are shorter,
there are fewer lines, but what is most important: the lines are easy
to understand, with a direct correspondence between code and math.

Let's trace our history, in this regard.  We started off writing with pen and
paper:

:equation:
\br_{1} = \br + \bv dt

In our first code, this became:

 :inccode: .euler_modified_1000_steps.rb-1

Then in our array code, it became

 :inccode: .euler_modified_array.rb-1

and finally, in our vector code, we wrote:

 :inccode: .euler_modified_vector.rb-1

which is very close indeed to what we started out with:

:equation:
\br_{1} = \br + \bv dt

*Dan*: It was a lot of work, but now that we got the vector class,
I must admit that the code looks a lot more readable.  So I guess
this will make life a lot easier for us.
But before we move on, does it give the correct answers?

*Carol*: Here's the old result, from the array code:

 :commandoutput: ruby euler_modified_array.rb | tail -1

and here's what our new vector code gives:

 :commandoutput: ruby euler_modified_vector.rb | tail -1

*Dan*: Good!  I'm happy.

<b>[ this is how far I got ; 2007/8/19 -- Piet ]</b>

== Leapfrog

*Carol*: Erica, what kind of second-order algorithm should we use,
to replace our first-order forward Euler scheme?

*Erica*: A nice and simple scheme is the _leapfrog_ algorithm.

*Dan*: What a strange name.  Does it let particles jump around like frogs?

*Carol*: Or like children jumping over each other?

*Erica*: Something like that, I guess.  I never thought about the meaning
of the name.  It is used quite widely, although it has different names in
different fields of science.  In stellar dynamics you often hear it called
leapfrog, but in molecular dynamics it is generally called the Verlet
method, and I'm sure there must be other names in use in other fields.

Here is the idea:

:eqnarray:
\br_{i} & = & \br_{i-1} + \bv_{i-1/2} dt \label{leapfrog-leap-step1} \\
\bv_{i+1/2} & = & \bv_{i-1/2} + \ba_i dt \label{leapfrog-leap-step2}

== xxx

== xxx

Here is 

<tt>leapfrog_100.rb</tt>:

 :inccode: .leapfrog_1000_steps.rb

Try:

 :commandoutput: ruby leapfrog_1000_steps.rb > leapfrog_1000_steps.out
 :commandinput: gnuplot END
set term post eps
set output "leapfrog_1000_steps.ps"
set size ratio -1
plot "leapfrog_1000_steps.out"
quit
END

:figure: leapfrog_1000_steps.ps 10cm leapfrog_1000_steps
First attempt at leapfrog integration, with stepsize <tex>$dt=0.01$</tex>.

xxx
