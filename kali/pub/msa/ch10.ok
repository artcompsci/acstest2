= Second-Order Integration Algorithms

== The Modified Euler Algorithm

*Dan*: Well, Erica, how are we going to move up to a more accurate
algorithm?

*Carol*: You mentioned something about a second-order scheme.

*Erica*: Yes, and there are several different choices.  With our
first-order approach, we had little choice.  Forward Euler was the
obvious one: just follow your nose, the way it is pointed at the 
beginning of the step, as in fig. ref(forward1).

*Dan*: You mentioned a backward Euler as well, and even drew a picture,
in in fig. ref(backward1).

*Erica*: That was only because you asked me about it!  And the backward
Euler scheme is not self-starting.  It is an implicit method, where you
have to know the answer before give calculate it.  As we discussed, you
can solve that through iteration, but then you have to take every step
twice, and you still only have a first-order method, so there is no good
reason to use that method.

*Dan*: But wait a minute, the two types of errors in figs. ref(forward1)
and ref(backward1) are clearly going in the opposite directions.
I mean, forward flies out of the curve one way, and backwards spiral in
the other way.  I wonder, can't you somehow combine the two methods and
see whether we can let the two errors cancel each other?

:figure: modforward1.eps 6cm modforward1
An attempt to improve the Euler methods.  The top arrow shows forward Euler,
and the bottom arrow backward Euler.  The dashed arrow shows the average
between the two, which clearly gives a better approximation to the curved
lines that show the true solutions to the differential equation.

:figure: modforward2.eps 6cm modforward2
Two successive forward Euler steps.

:figure: modforward3.eps 6cm modforward3
A forward Euler steps and a backward Euler step, landing at the same point.

If we combine the previous two pictures, the most natural thing would be
to try _both_ of the Euler types, forward and backward.  Here is a sketch,
in fig. ref(modforward1).  The top arrow is what we've done so far,
forward Euler, simply following the tangent line of the curve.  The
bottom line is backward Euler, taking a step that lands on a curve
with the right tangent at the end.  My idea is to compute both, and then
take the average between the two attempts.  I'm sure that would give a
better approximation!

*Carol*: But at a large cost!  The backward Euler method is an implicit
method, as Erica mentioned, that requires at least one extra iteration.
So the bottom arrow alone is much more expensive to compute than the top
arrow, and we have to compute both.

*Erica*: You are both right.  Dan's idea was brilliant!  Dan, were you
reading my mind?  What you proposed was the essential idea behind what
is called the modified Euler method.  And Carol hinted at the missing
piece.  Instead of computing both forward and backward right at the
start, it is more efficient to begin with a forward Euler step, and
then to compute the backward Euler step at the position where the forward
step landed.

Here, let me also draw a picture, in fig. ref(modforward2).  Here we
take one forward Euler step, and we then compute a second forward Euler
step, following the first one.  If we now shift the second arrow back,
so that the end of the arrow falls on the same point as the end of the
first arrow, we have constructed a backward Euler step that lands on the
same point where our forward Euler step landed, as you can see in
fig. ref(modforward3).

Of course, the top arrow in fig. ref(modforward3) is not exactly the
same arrow as the bottow arrow in fig. ref(modforward1), but the two
arrows are approximately the same, especially if our step sizes are
not too large.  So, in a first approximation, we can average the arrows
in fig. ref(modforward3).  This will make Carol happy: no more implicit
steps.  We have only taken forward steps, even though we recycle the
second one by interpreting it as a backward step.

:figure: modforward4.eps 6cm modforward4
The modified Euler approximation is indicated by the lower arrow, as
the average of the forward and backward Euler methode.  The
curved lines show the true solutions to the differential equation.

The simplest way to construct the average between the two vectors is by
adding them and then dividing the length by two.  Here it is, in fig.
fig. ref(modforward4).

*Dan*: Well, I don't know what hit me, but I'm glad my idea was useful!

*Erica*: What I've just drawn here has a name.  In the literature on
numerical solutions to differential equations it is called the
modified Euler method.  Modified in the sense of starting with forward
Euler, and then modifying it by taking backward Euler into account as
well.

== xxx

:eqnarray:
\label{ModEulerStepLong}
\br_{i+1, p} & = & \br_i + \bv_i dt                           \nonumber \\
\bv_{i+1, p} & = & \bv_i + \ba_i dt                           \nonumber \\
\br_{i+2, p} & = & \br_{i+1, p} + \bv_{i+1, p} dt             \nonumber \\
\bv_{i+2, p} & = & \bv_{i+1, p} + \ba_{i+1, p} dt             \nonumber \\
\br_{i+1, c} & = & \br_i + 
\half\left(\left(\br_{i+1, p} - \br_i\right)+
           \left(\br_{i+2, p} - \br_{i+1, p}\right)\right)    \nonumber \\
\bv_{i+1, c} & = & \bv_i + 
\half\left(\left(\bv_{i+1, p} - \bv_i\right)+
           \left(\bv_{i+2, p} - \bv_{i+1, p}\right)\right)    \nonumber \\

or shorter

:eqnarray:
\label{ModEulerStep}
\br_{i+1, p} & = & \br_i + \bv_i dt                           \nonumber \\
\bv_{i+1, p} & = & \bv_i + \ba_i dt                           \nonumber \\
\br_{i+2, p} & = & \br_{i+1, p} + \bv_{i+1, p} dt             \nonumber \\
\bv_{i+2, p} & = & \bv_{i+1, p} + \ba_{i+1, p} dt             \nonumber \\
\br_{i+1, c} & = & \br_i + 
   \half\left(\br_{i+2, p} - \br_i\right)                     \nonumber \\
\bv_{i+1, c} & = & \bv_i + 
   \half\left(\bv_{i+2, p} - \bv_i\right)                     \nonumber \\

== xxx

== xxx

== leapfrog

*Carol*: Erica, what kind of second-order algorithm should we use,
to replace our first-order forward Euler scheme?

*Erica*: A nice and simple scheme is the _leapfrog_ algorithm.

*Dan*: What a strange name.  Does it let particles jump around like frogs?

*Carol*: Or like children jumping over each other?

*Erica*: Something like that, I guess.  I never thought about the meaning
of the name.  It is used quite widely, although it has different names in
different fields of science.  In stellar dynamics you often hear it called
leapfrog, but in molecular dynamics it is generally called the Verlet
method, and I'm sure there must be other names in use in other fields.

Here is the idea:

:eqnarray:
\br_{i} & = & \br_{i-1} + \bv_{i-1/2} dt \label{leapfrog-leap-step1} \\
\bv_{i+1/2} & = & \bv_{i-1/2} + \ba_i dt \label{leapfrog-leap-step2}






<b>* * * * * * *  This is how far I got, 2007/5/12  * * * * * * * </b>


