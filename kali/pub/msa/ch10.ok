= Second-Order Integration Algorithms

== A Wild Idea

*Dan*: Well, Erica, how are we going to move up to a more accurate
algorithm?

*Carol*: You mentioned something about a second-order scheme.

*Erica*: Yes, and there are several different choices.  With our
first-order approach, we had little choice.  Forward Euler was the
obvious one: just follow your nose, the way it is pointed at the 
beginning of the step, as in fig. ref(forward1).

*Dan*: You mentioned a backward Euler as well, and even drew a picture,
in in fig. ref(backward1).

*Erica*: That was only because you asked me about it!  And the backward
Euler scheme is not an explicit method.  It is an implicit method, where
you have to know the answer before give calculate it.  As we discussed, you
can solve that through iteration, but then you have to take every step
twice, and you still only have a first-order method, so there is no good
reason to use that method.

*Dan*: But wait a minute, the two types of errors in figs. ref(forward1)
and ref(backward1) are clearly going in the opposite directions.
I mean, forward flies out of the curve one way, and backwards spiral in
the other way.  I wonder, can't you somehow combine the two methods and
see whether we can let the two errors cancel each other?

If we combine the previous two pictures, the most natural thing would be
to try _both_ of the Euler types, forward and backward.  Here is a sketch,
in fig. ref(modforward1).  The top arrow is what we've done so far,
forward Euler, simply following the tangent line of the curve.  The
bottom line is backward Euler, taking a step that lands on a curve
with the right tangent at the end.  My idea is to compute both, and then
take the average between the two attempts.  I'm sure that would give a
better approximation!

:figure: modforward1.eps 8cm modforward1
An attempt to improve the Euler methods.  The top arrow shows forward Euler,
and the bottom arrow backward Euler.  The dashed arrow shows the average
between the two, which clearly gives a better approximation to the curved
lines that show the true solutions to the differential equation.

*Carol*: But at a large cost!  The backward Euler method is an implicit
method, as Erica mentioned, that requires at least one extra iteration.
So the bottom arrow alone is much more expensive to compute than the top
arrow, and we have to compute both.

*Dan*: It was just a wild idea, and it may not be useful.

== Backwards and Forwards

*Erica*: I must say, I like Dan's idea, and perhaps we can make it a bit more
efficient.  How about shifting the arrow of the backwards step to the end
of the arrow of the forwards step, as in fig. ref(modforward2)?  Or to be
precise, how about just taking two forward Euler steps, one after the other?
The second forward step will not produce exactly the same arrow as the first
backward step, but it will be almost the same arrow, and perhaps such an
approximation would be good enough.

:figure: modforward2.eps 8cm modforward2
Two successive forward Euler steps.

*Dan*: But how are you going to use that to construct the dashed line in
fig. ref(modforward1)?

*Erica*: Let's see.  How about starting with fig. ref(modforward1), and
then shifting the second arrow back, so that the end of the arrow falls
on the same point as the end of the first arrow?  In that way, we have
constructed a backward Euler step that lands on the same point where our
forward Euler step landed, as you can see in fig. ref(modforward3).

:figure: modforward3.eps 8cm modforward3
A forward Euler steps and a backward Euler step, landing at the same point.

As I already admitted, the top arrow in fig. ref(modforward3) is not exactly
the same arrow as the bottow arrow in fig. ref(modforward1), but the two
arrows are approximately the same, especially if our step sizes are
not too large.  So, in a first approximation, we can average the arrows
in fig. ref(modforward3).  This will make Carol happy: no more implicit
steps.  We have only taken forward steps, even though we recycle the
second one by interpreting it as a backward step.

The simplest way to construct the average between the two vectors is by
adding them and then dividing the length by two.  Here it is, in
fig. ref(modforward4).

:figure: modforward4.eps 8cm modforward4
The new integration scheme produces the dashed arrow, as exactly one-half of
the some of the two fully drawn arrows; the dotted arrow has the same length
as the dashed arrow.  This result is approximately the same as the dashed
arrow in fig. ref(modforward1).

*Dan*: That looks like a promising approach.  Let's write a code for it.

<b>[ this is how far I got ; 2007/7/13 -- Piet ]</b>

== Implementation

*Carol*: It should be easy to implement this new scheme.  The picture
we have drawn shows the change in position of a particle, and we
should apply the same idea to the change in velocity.

For starters, let us just look at the position.  First we have to
introduce some notation.

*Erica*: In the literature, people often talk about predictor-corrector
methods.  The idea is that you first make a rough prediction about a
future position, and then you make a correction, after you had
evaluated the forces at that predicted position.

In our case, in fig. ref(modforward4), the first solid arrow starts at
the original point <tex>$\br_i$</tex>.  Let us call the end point of that
arrow <tex>$\br_{i+1, p}$</tex>, where the _p_ stands for _predicted_,
as the predicted result of taking a forward Euler step:

:equation:
\br_{i+1, p} = \br_i + \bv_i dt

The second arrow shows another prediction, namely for yet another
forward Euler step, which lands us at <tex>$\br_{i+2, p}$</tex>:

:equation:
\br_{i+2, p} = \br_{i+1, p} + \bv_{i+1, p} dt

*Dan*: But here you are using the velocity at time <tex>$i+1$</tex>,
something that you haven't calculated yet.

*Erica*: I know, we'll come to that in a moment.  I just wanted to write
the position part first.

We can find the _corrected_ new position by taking the average of the
first two forward Euler steps, as indicated in fig. ref(modforward4):

:eqnarray:
\label{ModEulerStepLong}
\br_{i+1, c} & = & \br_i + 
\half\left\{\left(\br_{i+1, p} - \br_i\right)+
           \left(\br_{i+2, p} - \br_{i+1, p}\right)\right\}    \nonumber \\
& = & \br_i + \half\left(\br_{i+2, p} - \br_i\right)           \nonumber \\
& = & \half\left(\br_i + \br_{i+2, p}\right)

*Carol*: As Dan pointed out, we have to do a similar thing for the velocities.
I guess that everything carries over, but with <tex>$\bv$</tex> instead
of <tex>$\br$</tex> and <tex>$\ba$</tex> instead of <tex>$\ba$</tex>.

*Erica*: Yes, in fact it is just a matter of differentiating the previous
lines with respect to time.  Putting it all together, we then get:

:eqnarray:
\label{ModEulerStep}
\br_{i+1, p} & = & \br_i + \bv_i dt                           \nonumber \\
\bv_{i+1, p} & = & \bv_i + \ba_i dt                           \nonumber \\
\br_{i+2, p} & = & \br_{i+1, p} + \bv_{i+1, p} dt             \nonumber \\
\bv_{i+2, p} & = & \bv_{i+1, p} + \ba_{i+1, p} dt             \nonumber \\
\br_{i+1, c} & = & \half\left(\br_i + \br_{i+2, p}\right)     \nonumber \\
\bv_{i+1, c} & = & \half\left(\bv_i + \bv_{i+2, p}\right)

== xxx

Here is 

<tt>euler_modified_1000_sparse.rb</tt>:

 :inccode: .euler_modified_1000_sparse.rb

Try:

 :commandoutput: ruby euler_modified_1000_sparse.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "euler_modified_1000_sparse.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_modified_1000_sparse.ps 10cm euler_modified_1000_sparse
First attempt at modified Euler integration, with stepsize
<tex>$dt=0.001$</tex>.

Wow!!!  Too good to be true.  Let's try 10 times later steps.

== xxx

Here is 

<tt>euler_modified_100.rb</tt>:

 :inccode: .euler_modified_100.rb

Try:

 :commandoutput: ruby euler_modified_100.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "euler_modified_100.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: euler_modified_100.ps 10cm euler_modified_100
Second attempt at modified Euler integration, with stepsize
<tex>$dt=0.01$</tex>.



== The Modified Euler Algorithm

== xxx

== leapfrog

*Carol*: Erica, what kind of second-order algorithm should we use,
to replace our first-order forward Euler scheme?

*Erica*: A nice and simple scheme is the _leapfrog_ algorithm.

*Dan*: What a strange name.  Does it let particles jump around like frogs?

*Carol*: Or like children jumping over each other?

*Erica*: Something like that, I guess.  I never thought about the meaning
of the name.  It is used quite widely, although it has different names in
different fields of science.  In stellar dynamics you often hear it called
leapfrog, but in molecular dynamics it is generally called the Verlet
method, and I'm sure there must be other names in use in other fields.

Here is the idea:

:eqnarray:
\br_{i} & = & \br_{i-1} + \bv_{i-1/2} dt \label{leapfrog-leap-step1} \\
\bv_{i+1/2} & = & \bv_{i-1/2} + \ba_i dt \label{leapfrog-leap-step2}

== xxx

== xxx

Here is 

<tt>leapfrog_100.rb</tt>:

 :inccode: .leapfrog_100.rb

Try:

 :commandoutput: ruby leapfrog_100.rb > euler.out
 :commandinput: gnuplot END
set term post eps
set output "leapfrog_100.ps"
set size ratio -1
plot "euler.out"
quit
END

:figure: leapfrog_100.ps 10cm leapfrog_100
First attempt at leapfrog integration, with stepsize <tex>$dt=0.01$</tex>.







<b>* * * * * * *  This is how far I got, 2007/5/19  * * * * * * * </b>

